<!DOCTYPE html>
<html>
<head>
<title>JSON-LD - Linked Data Expression in JSON</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- 
  === NOTA BENE ===
  For the three scripts below, if your spec resides on dev.w3 you can check them
  out in the same tree and use relative links so that they'll work offline,
  -->
<script type="text/javascript"
  src="http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js" class="remove">
 </script>
<script type="text/javascript" class="remove">

    var preProc = {
          apply:  function(c) {
                    // extend the bibliography entries
                    berjon.biblio["MICRODATA"] = "Ian Hickson; et al. <a href=\"http://www.w3.org/TR/microdata/\"><cite>Microdata</cite></a> 04 March 2010. W3C Working Draft. URL: <a href=\"http://www.w3.org/TR/microdata/\">http://www.w3.org/TR/microdata/</a> ";
                    berjon.biblio["HTML-RDFA"] = "Manu Sporny; et al. <a href=\"http://www.w3.org/TR/rdfa-in-html/\"><cite>HTML+RDFa</cite></a> 04 March 2010. W3C Working Draft. URL: <a href=\"http://www.w3.org/TR/rdfa-in-html/\">http://www.w3.org/TR/rdfa-in-html/</a> ";
                    berjon.biblio["BCP47"] = "A. Phillips, M. Davis. <a href=\"http://tools.ietf.org/rfc/bcp/bcp47.txt\"><cite>Tags for Identifying Languages</cite></a> September 2009. IETF Best Current Practice. URL: <a href=\"http://tools.ietf.org/rfc/bcp/bcp47.txt\">http://tools.ietf.org/rfc/bcp/bcp47.txt</a>";
                    
                    // process the document before anything else is done
                    var refs = document.querySelectorAll('adef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'dfn' ) ;
                        var tit = item.getAttribute('title') ;
                        if (!tit) {
                            tit = con;
                        }
                        sp.className = 'adef' ;
                        sp.title=tit ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    refs = document.querySelectorAll('aref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'aref' ;
                        sp.setAttribute('title', con);
                        sp.innerHTML = '@'+con ;
                        p.replaceChild(sp, item) ;
                    }
                    // local datatype references
                    refs = document.querySelectorAll('ldtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'datatype';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // external datatype references
                    refs = document.querySelectorAll('dtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'externalDFN';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now do terms
                    refs = document.querySelectorAll('tdef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'dfn' ) ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now term references
                    refs = document.querySelectorAll('tref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }

                        var sp = document.createElement( 'a' ) ;
                        var id = item.textContent ;
                        sp.className = 'tref' ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                }
        } ;


      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          //publishDate:          "2010-04-29",
          //copyrightStart:       "2010",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "json-ld",
          subtitle:             "A Context-based JSON Serialization for Linked Data",
          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2010-08-23",
          previousMaturity:  "ED",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://json-ld.org/spec/latest/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS:             [
              "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
              "spec.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
          ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          authors:  [
              { name: "Mark Birbeck", url: "http://webbackplane.com/",
                company: "Backplane Ltd.", companyURL: "http://webbackplane.com/" },
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
          ],
          
          // name of the WG
          wg:           "RDFa Next Working Group",
          
          // URI of the public WG page
          wgURI:        "",
          
          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          maxTocLevel: 3,
          preProcess: [ preProc ],
          //alternateFormats: [ {uri: "diff-20100823.html", label: "diff to previous version"} ],
      };

      function updateExample(doc, content) {
        // perform transformations to make it render and prettier
        content = content.replace(/<!--/, '');
        content = content.replace(/-->/, '');
        content = doc._esc(content);
        content = content.replace(/\*\*\*\*([^*]*)\*\*\*\*/g, '<span class="diff">$1</span>') ;
        return content ;
      }

      function updateDTD(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/!ENTITY % ([^ \t\r\n]*)/g, '!ENTITY <span class="entity">% $1</span>');
        content = content.replace(/!ELEMENT ([^ \t$]*)/mg, '!ELEMENT <span class="element">$1</span>');
        return content;
      }

      function updateSchema(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/&lt;xs:element\s+name=&quot;([^&]*)&quot;/g, '&lt;xs:element name="<span class="element" id="schema_element_$1">$1</span>"') ;
        return content;
      }

      function updateTTL(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="sh_sourceCode">' + doc._esc(content) + '</pre>';
        content = content.replace(/@prefix/g, '<span class="sh_keyword">@prefix</span>');
        return content;
      }
  </script>
<style>
.diff { font-weight:bold; color:#0a3; }
</style>
</head>

<body>
<section id="abstract">
<p>
Developers that embed structured data in their Web pages can choose among
a number of languages such as RDFa [[RDFA-CORE]], Microformats [[MICROFORMATS]] 
and Microdata [[MICRODATA]]. Each of these structured data languages, while
incompatible at the syntax level, can be easily mapped to RDF. JSON has 
proven to be a highly useful object serialization and messaging format. 
In an attempt to harmonize the representation of Linked Data in JSON, 
this specification outlines a common JSON representation format for 
Linked Data that can be used to represent objects specified via RDFa, 
Microformats and Microdata.
</p>
</section>

<section>
<h3>How to Read this Document</h3>

<p>
This document is a detailed specification for a serialization of JSON for Linked
data. The document is primarily intended for the following audiences:
</p>

<ul>
  <li>Developers that want to encode Microformats, RDFa, or Microdata in a
  way that is cross-language compatible via JSON.</li>
  <li>Developers that want to understand the encoding possibilities.</li>
</ul>

<p>
To understand this specification you must first be familiar with JSON, 
which is detailed in [[!RFC4627]].</p>

</section>

<section id='sotd'>
<p>This document is an experimental work in progress.</p>
<!-- <p>
This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from another
document. W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This
enhances the functionality and interoperability of the Web.
</p> -->
</section>

<section>
<h1>Introduction</h1>

<p class="issue">Write the introduction once all of the technical details
are hammered out. Explain why JSON-LD is designed as a light-weight mechanism
to express RDFa, Microformats and Microdata. It is primarily intended as
a way to express Linked Data in Javascript environments as well as a way to pass
Linked Data to and from Web services. It is designed to be as simple as 
possible, utilizing the large number of JSON parsers (and understanding) that
is out there already. It is designed to be able to express key-value pairs,
RDF data, Microformats data, and Microdata (that is, every data model
currently in use) using one unified format. It does not require anyone to change
their JSON, but easily add meaning by adding context in a way that is 
out-of-band - it is designed to not disturb already deployed systems running
on JSON, but provide a smooth migration path from JSON to JSON with added
semantics. Finally, the format is intended to be fast to parse, fast to 
generate, stream-based and document-based processing compatible, and require
a tiny memory footprint in order to operate.
</p>
</section>

<section>
<h1>Design Goals</h1>

<p>
A number of design considerations were explored during the creation of this 
markup language:
</p>

<dl>
 <dt>Simplicity</dt>
 <dd>Developers don't need to know RDF in order to use the basic functionality
 provided by JSON-LD.</dd>
 <dt>Compatibility</dt>
 <dd>The JSON-LD markup should be 100% compatible with JSON.</dd>
 <dt>Expressiveness</dt>
 <dd>All major RDF concepts must be expressible via the JSON-LD syntax.</dd>
 <dt>Terseness</dt>
 <dd>The JSON-LD syntax must be very terse and human readable.</dd>
 <dt>Zero Edits</dt>
 <dd>JSON-LD provides a mechanism that allows developers to specify 
 context in a way that is out-of-band. This allows organizations that have
 already deployed large JSON-based infrastructure to add meaning to their
 JSON in a way that is not disruptive to their day-to-day operations and is
 transparent to their current customers.</dd>
 <dt>Streaming</dt>
 <dd>The format supports both document-based and stream-based processing.</dd>
</dl>
</section>

<section>
<h1>Design Rationale</h1>

<p>The following section outlines the rationale behind the JSON-LD markup
language.
</p>

<section>
<h2>Map Terms to IRIs</h2>

<p>Establishing a mechanism to map JSON values to IRIs will
help in the mapping of JSON objects to RDF. This does not mean that JSON-LD must
be restrictive in declaring a set of terms, rather, experimentation and 
innovation should be supported as part of the core design of JSON-LD. There are, 
however, a number of very small design criterial that can ensure that developers 
will generate good RDF data that will create value for the greater 
semantic web community and JSON/REST-based Web Services community.
</p>

<p>We will be using the following JSON object as the example for this section:
</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "a": "Person",
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/"
}
-->
</pre>
</section>

<section>
<h3>The Default Context</h3>

<p>A default context is used in RDFa to allow developers to use keywords
as aliases for IRIs. So, for instance, the keyword <strong>name</strong>
above could refer to the IRI <em>http://xmlns.com/foaf/0.1/name</em>.
The semantic web, just like the document-based web, uses IRIs for
unambiguous identification. The idea is that these terms mean something, 
which you will eventually want to query. The semantic web specifies this via 
<em>Vocabulary Documents</em>. The IRI <em>http://xmlns.com/foaf/0.1/</em> specifies
a Vocabulary Document, and <strong>name</strong> is a term in that 
vocabulary. Paste the two items together and you have an unambiguous identifier
for a term.
</p>

<p>Developers, and machines, would be able to use this IRI (plugging it
directly into a web browser, for instance) to go to the term and get a 
definition of what the term means. Much
like we can use WordNet today to see the 
<a href="http://wordnetweb.princeton.edu/perl/webwn?s=definition">definition</a>
of words in the English language. Machines need the same sort of 
dictionary of terms, and URIs provide a way to ensure that these terms
are unambiguous.
</p>

<p>Non-prefixed terms should have term mappings declared in the default
context so that they may be expanded later.</p>
            
<p>If a set of terms, like <strong>Person</strong>, 
<strong>name</strong>, and <strong>homepage</strong>,
are pre-defined in the default context, and that context is used to resolve the
names in JSON objects, machines could automatically expand the terms to 
something meaningful and unambiguous, like this:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "****http://www.w3.org/1999/02/22-rdf-syntax-ns#type****": "****http://xmlns.com/foaf/0.1/Person****",
  "****http://xmlns.com/foaf/0.1/name****": "Manu Sporny",
  "****http://xmlns.com/foaf/0.1/homepage****": "****<****http://manu.sporny.org****>****"
}
 -->
</pre>

<p class="note">In order to differentiate between plain text and IRIs, the
<strong>&lt;</strong> and <strong>&gt;</strong> are used around IRIs.</p>

<p>Doing this would mean that JSON would start to become unambiguously
machine-readable, play well with the semantic web, and basic markup wouldn't 
be that much more complex than basic JSON markup. A win, all around.</p>
</section>

<section>
<h3>Mashing Up Vocabularies</h3>

<p>Developers would also benefit by allowing other vocabularies to be used
automatically with their JSON API. There are over 200 
Vocabulary Documents that are available for use on the Web today. Some
of these vocabularies are:
</p>

<ul>
   <li>XSD - for specifying basic types like strings, integers, dates and times.</li>
   <li>Dublin Core - for describing creative works.</li>
   <li>FOAF - for describing social networks.</li>
   <li>Calendar - for specifying events.</li>
   <li>SIOC - for describing discussions on blogs and websites.</li>
   <li>CCrel - for describing Creative Commons and other types of licenses.</li>
   <li>GEO - for describing geographic location.</li>
   <li>VCard - for describing organizations and people.</li>
   <li>DOAP - for describing projects.</li>
</ul>

<p>A JSON-LD Web Service could define these as <em>prefix</em>es in their 
default context beside the <em>terms</em> that are already defined. Using
this feature, developers could also express markup like this:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "****rdf:type****": "****foaf:Person****",
  "****foaf:name****": "Manu Sporny",
  "****foaf:homepage****": "<http://manu.sporny.org/>"****,
  "sioc:avatar": "<http://twitter.com/account/profile_image/manusporny>"****
}
-->
</pre>

<p>Developers can also specify their own Vocabulary documents by modifying the 
default context in-line using the <code>#</code> character, like so:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  ****"#": { "myvocab": "http://example.org/myvocab#" }****,
  "a": "foaf:Person",
  "foaf:name": "Manu Sporny",
  "foaf:homepage": "<http://manu.sporny.org/>",
  "sioc:avatar": "<http://twitter.com/account/profile_image/manusporny>"****,
  "myvocab:credits": 500****
}

-->
</pre>

<p>Think of the <code>#</code> character as a "hashtable", which maps one
string to another string. In the example above, the <code>myvocab</code>
string is replaced with "<code>http://example.org/myvocab#</code>" when it
is detected above. In the example above, "<code>myvocab:credits</code>" would
expand to "<code>http://example.org/myvocab#credits</code>".</p>

<p>This mechanism is a short-hand for RDF, and if defined, will give
developers an unambiguous way to map any JSON value to RDF.<p>

</section>

<section>
<h3>An Example of a Default Context</h3>

<p>JSON-LD strives to ensure that developers don't have to change the JSON
that is going into and being returned from their Web applications. A JSON-LD 
aware Web Service MAY define a default context. For example, the
following default context could apply to all incoming Web Service calls
previously accepting only JSON data:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "#": 
  {
    "__vocab__": "http://example.org/default-vocab#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dc": "http://purl.org/dc/terms/",
    "foaf": "http://xmlns.com/foaf/0.1/",
    "sioc": "http://rdfs.org/sioc/ns#",
    "cc": "http://creativecommons.org/ns#",
    "geo": "http://www.w3.org/2003/01/geo/wgs84_pos#",
    "vcard": "http://www.w3.org/2006/vcard/ns#",
    "cal": "http://www.w3.org/2002/12/cal/ical#",
    "doap": "http://usefulinc.com/ns/doap#",
    "Person": "http://xmlns.com/foaf/0.1/Person",
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": "http://xmlns.com/foaf/0.1/homepage"
  }
}
-->
</pre>

<p>The <code>__vocab__</code> prefix is a special prefix that states 
that any term that doesn't resolve to a term or a prefix should be 
appended to the <code>__vocab__</code> IRI. This is done to ensure that 
terms can be transformed to an IRI at all times.
</p>
</section>
</section>

<section>
<h2>Markup Examples</h2>

<p>The JSON-LD markup examples below demonstrate how JSON-LD can be used to
express semantic data marked up in other languages such as RDFa, Microformats,
and Microdata. These sections are merely provided as proof that JSON-LD is
very flexible in what it can express across different Linked Data approaches.
</p>

<section>
<h3>RDFa</h3>

<p>The following example describes three people with their respective names and
homepages.</p>

<pre class="example" data-transform="updateExample">
<!--
<div ****prefix="foaf: http://xmlns.com/foaf/0.1/"****>
   <ul>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/bob/" property="foaf:name" ****>Bob</a>
      </li>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/eve/" property="foaf:name" ****>Eve</a>
      </li>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/manu/" property="foaf:name" ****>Manu</a>
      </li>
   </ul>
</div>
-->
</pre>

<p>An example JSON-LD implementation is described below, however, there are
other ways to mark-up this information such that the context is not
repeated.</p>

<pre class="example" data-transform="updateExample">
<!--
[
 {
   "#": { "foaf": "http://xmlns.com/foaf/0.1/" },
   "@": "_:bnode1",
   "a": "foaf:Person",
   "foaf:homepage": "<http://example.com/bob/>",
   "foaf:name": "Bob"
 },
 {
   "#": { "foaf": "http://xmlns.com/foaf/0.1/" },
   "@": "_:bnode2",
   "a": "foaf:Person",
   "foaf:homepage": "<http://example.com/eve/>",
   "foaf:name": "Eve"
 },
 {
   "#": { "foaf": "http://xmlns.com/foaf/0.1/" },
   "@": "_:bnode3",
   "a": "foaf:Person",
   "foaf:homepage": "<http://example.com/manu/>",
   "foaf:name": "Manu"
 }
]
-->
</pre>

</section>

<section>
<h3>Microformats</h3>

<p>The following example uses a simple Microformats hCard example to express
how the Microformat is represented in JSON-LD.</p>

<pre class="example" data-transform="updateExample">
<!--
<div class="vcard">
 <a class="url fn" href="http://tantek.com/">Tantek Çelik</a>
</div>
-->
</pre>

<p>The representation of the hCard expresses the Microformat terms in the
context and uses them directly for the <code>url</code> and <code>fn</code>
properties. Also note that the Microformat to JSON-LD processor has 
generated the proper URL type for <code>http://tantek.com</code>.</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "#": 
  {
    "vcard": "http://microformats.org/profile/hcard#vcard"
    "url": "http://microformats.org/profile/hcard#url"
    "fn": "http://microformats.org/profile/hcard#fn"
  },
  "@": "_:bnode1",
  "a": "vcard",
  "url": "<http://tantek.com/>",
  "fn": "Tantek Çelik"
}
-->
</pre>

</section>

<section>
<h3>Microdata</h3>

<p>The Microdata example below expresses book information as a Microdata Work
item.
</p>

<pre class="example" data-transform="updateExample">
<!--
<dl itemscope
    itemtype="http://purl.org/vocab/frbr/core#Work"
    itemid="http://purl.oreilly.com/works/45U8QJGZSQKDH8N">
 <dt>Title</dt>
 <dd><cite itemprop="http://purl.org/dc/terms/title">Just a Geek</cite></dd>
 <dt>By</dt>
 <dd><span itemprop="http://purl.org/dc/terms/creator">Wil Wheaton</span></dd>
 <dt>Format</dt>
 <dd itemprop="http://purl.org/vocab/frbr/core#realization"
     itemscope
     itemtype="http://purl.org/vocab/frbr/core#Expression"
     itemid="http://purl.oreilly.com/products/9780596007683.BOOK">
  <link itemprop="http://purl.org/dc/terms/type" href="http://purl.oreilly.com/product-types/BOOK">
  Print
 </dd>
 <dd itemprop="http://purl.org/vocab/frbr/core#realization"
     itemscope
     itemtype="http://purl.org/vocab/frbr/core#Expression"
     itemid="http://purl.oreilly.com/products/9780596802189.EBOOK">
  <link itemprop="http://purl.org/dc/terms/type" href="http://purl.oreilly.com/product-types/EBOOK">
  Ebook
 </dd>
</dl>
-->
</pre>

<p>Note that the JSON-LD representation of the Microdata information stays
true to the desires of the Microdata community to avoid contexts and
instead refer to items by their full IRI.</p>

<pre class="example" data-transform="updateExample">
<!--
[
  {
    "@": "<http://purl.oreilly.com/works/45U8QJGZSQKDH8N>",
    "a": "http://purl.org/vocab/frbr/core#Work",
    "http://purl.org/dc/terms/title": "Just a Geek",
    "http://purl.org/dc/terms/creator": "Whil Wheaton",
    "http://purl.org/vocab/frbr/core#realization": 
      ["<http://purl.oreilly.com/products/9780596007683.BOOK>", "<http://purl.oreilly.com/products/9780596802189.EBOOK>"]
  },
  {
    "@": "<http://purl.oreilly.com/products/9780596007683.BOOK>",
    "a": "<http://purl.org/vocab/frbr/core#Expression>",
    "http://purl.org/dc/terms/type": "<http://purl.oreilly.com/product-types/BOOK>"
  },
  {
    "@": "<http://purl.oreilly.com/products/9780596802189.EBOOK>",
    "a": "http://purl.org/vocab/frbr/core#Expression",
    "http://purl.org/dc/terms/type": "<http://purl.oreilly.com/product-types/EBOOK>"
  }
]
-->
</pre>
</section>
</section>

<section>
<h3>The JSON-LD Processing Algorithm</h3>

<p>
The processing algorithm described in this section is provided in
order to demonstrate how one might implement a JSON-LD processor. 
Conformant implementations are only required to produce the same type and
number of triples during the output process and are not required to 
implement the algorithm exactly as described.
</p>

<p class="issue">The Processing Algorithm is a work in progress, there are
still major bugs in the algorithm and it's difficult to follow. It's provided
only to very early implementers to give them an idea of how to implement a
processor.</p>

<h4>Processing Algorithm Terms</h4>
<ul>
<li><tdef>default context</tdef> - a context that is specified to the
JSON-LD processing algorithm before processing begins.</li>
<li><tdef>default graph</tdef> - the destination graph for all triples
generated by JSON-LD markup.</li>
<li><tdef>active subject</tdef> - the currently active subject that the
processor should use when generating triples.</li>
<li><tdef>inherited subject</tdef> - a subject that was detected at a
higher level of processing to be used to generate a triple once a 
<tref>current subject</tref> is discovered or generated.</li>
<li><tdef>active property</tdef> - the currently active property that the
processor should use when generating triples.</li>
<li><tdef>inherited property</tdef> - a property that was detected at a
higher level of processing to be used to generate a triple once a 
<tref>current subject</tref> is discovered or generated.</li>
<li><tdef>active object</tdef> - the currently active object that the
processor should use when generating triples.</li>
<li><tdef>active context</tdef> - a context that is used to resolve
CURIEs while the processing algorithm is running. The 
<tref>active context</tref> is the top-most item on the 
<tref>active context</tref> stack.</li>
<li><tdef>local context</tdef> - a context that is specified at the JSON
associative-array level, specified via the <code>#</code> key.</li>
<li><tdef>list of incomplete triples</tdef> - A list of triples that have
yet to have their subject set.</li>
<li><tdef>list of unprocessed items</tdef> - A list of objects that cannot be
processed until a <tref>local context</tref> is detected or the end of the
current associative-array is detected.</li>
<li><tdef>processor state</tdef> - the processor state, which includes
the <tref>active context</tref> stack, <tref>current subject</tref>, 
<tref>current property</tref>,
<tref>list of incomplete triples</tref>, and the 
<tref>list of unprocessed items</tref>.
</ul>

<p>The algorithm below is designed for streaming (SAX-based) implementations.
Implementers will find that non-streaming (document-based) implementations will
be much easier to implement as full access to the JSON object model eliminates 
some of the steps that are necessary for streaming implementations. A conforming
JSON-LD processor MUST implement a processing algorithm that results in the 
same <tref>default graph</tref> that the following algorithm generates:</p>

<ol class="algorithm">
<li id="processing-step-default-context">If a <tref>default context</tref> is 
supplied to the
processing algorithm, push it onto the <tref>active context</tref> stack.</li>

<li id="processing-step-associative">If an associative array is 
detected, create a new
<tref>processor state</tref>. Copy the <tref>current context</tref> stack to
the newly created <tref>processor state</tref>. Push the 
<tref>active context</tref> onto the newly created 
<tref>processor state</tref>'s <tref>active context</tref> stack. For each 
key-value pair in the associative array, using the newly created
<tref>processor state</tref> do the following:

  <ol class="algorithm">

    <li>If a <code>#</code> key is found, the processor
    merges each key-value pair in the <tref>local context</tref> into the
    <tref>active context</tref>, overwriting
    any duplicate values in the <tref>active context</tref>. 
    Process each object in the <tref>list of unprocessed items</tref>, 
    starting at <a href="#processing-subject">Step 2.2</a>.</li>

    <li id="processing-associative">If the <tref>local context</tref> has not been detected, the current
    key-value pair is placed into the <tref>list of unprocessed items</tref>
    and processing proceeds to the next key-value pair. Otherwise, if the
    <tref>local context</tref> is known perform the following steps:</li>

    <ol class="algorithm">

      <li id="processing-subject">If a <code>@</code> key is found, the 
      processor sets the <tref>active subject</tref> to the value after 
      <a href="#markup-of-rdf-concepts">Object Processing</a> has been performed.

      <ol class="algorithm">
        <li>If the <tref>inherited subject</tref> and 
        <tref>inherited property</tref> values are specified, generate a triple
        using the <tref>inherited subject</tref> for the subject, the
        <tref>inherited property</tref> for the property, and the 
        <tref>active subject</tref> for the object.
        </li>
 
        <li>If there are any triples in the 
        <tref>list of incomplete triples</tref>, complete each triple using the 
        <tref>active subject</tref> as the subject for each triple.
        </li>
      </ol>

      </li>

      <li>If an <code>a</code> key is found, set the <tref>active property</tref> 
      to <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#type</code>.
      </li>

      <li>If a key that is not <code>#</code>, 
      <code>@</code>, or <code>a</code> is found, set the 
      <tref>active property</tref> by performing 
      <a href="#markup-of-rdf-concepts">Property Processing</a> on the key.
      </li>

      <li>If the value is not an array, set the 
      <tref>active object</tref> by performing 
      <a href="#markup-of-rdf-concepts">Object Processing</a> on the value. 
      Generate a triple representing the <tref>active subject</tref>, the
      <tref>active property</tref> and the <tref>active object</tref>.</li>

      <li>If the value is an associative array, then
      process the value starting at 
      <a href="#processing-step-associative">Step 2</a>.</li>

      <li>If the value is a regular array, then process the value 
      starting at 
      <a href="#processing-step-array">Step 3</a> ensuring that
      the <tref>active subject</tref> and the <tref>active property</tref>
      are copied to a newly created <tref>processor state</tref>.</li>

      <li>If the end of the associative array is detected, and a
      <tref>active subject</tref> was not discovered, then:
      
      <ol class="algorithm">
        <li>Generate a <tref>blank node identifier</tref> and set it as the 
        <tref>active subject</tref>.</li>

        <li>Complete any previously incomplete triples by running all substeps 
        of <a href="#processing-subject">Step 2.2.1</a>.
        </li>
      </ol>

      <li>If the end of the associative array is detected, and a
      <tref>local context</tref> was not discovered, then assume that the
      <tref>active context</tref> is unmodified and run all substeps of
      <a href="#processing-associative">Step 2.2</a>
      on the <tref>list of unprocessed items</tref>.
     </ol>
    </ol>
  </li>

  <li id="processing-step-array">If a regular array is detected, 
  process each value in the array by doing the following:

    <ol class="algorithm">
      <li>If the value is an associative array, processes per 
      <a href="#processing-step-associative">Step 2</a>, ensuring to set
      the <tref>inherited subject</tref> to the <tref>active subject</tref>
      and the <tref>inherited property</tref> to the <tref>active property</tref>
      in the newly created <tref>processor state</tref>.</li>

      <li>If the value is not an array, set the <tref>active object</tref> 
      by performing <a href="#markup-of-rdf-concepts">Object Processing</a> on 
      the value. Generate a triple representing the <tref>active subject</tref>, 
      the <tref>active property</tref> and the <tref>active object</tref> and 
      place it into the <tref>default graph</tref>.</li>

      <li>If the value is a regular array, should we support RDF 
      List/Sequence Processing? 
      <div class="issue">If the value is a regular array, should we support 
      RDF List/Sequence generation of triples? For example, would implementing
      this be worth the more complex processing rules: "ex:orderedItems" : 
      [["one", "two", "three"]]</div></li>
    </ol>
  </li>
</ol>

</section>

<section>
<h1>Markup of RDF Concepts</h1>

<p>JSON-LD is designed to ensure that most Linked Data concepts can be marked up
in a way that is simple to understand and author by Web developers. In many
cases, Javascript objects can become Linked Data with the simple addition
of a context. Since RDF is also an important sub-community of the Linked
Data movement, it is important that all RDF concepts are well-represented
in this specification. This section details how each RDF concept can be
expressed in JSON-LD.</p>

<section>
<h2>IRIs</h2>

<p>Expressing IRIs are fundamental to Linked Data as that is how most subjects
and many objects are identified. IRIs can be expressed by wrapping a
text string with the <code>&lt;</code> and <code>&gt;</code> characters.
</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "foaf:homepage": "****<****http://manu.sporny.org****>****",
...
}
-->
</pre>

<p>The example above would set the object to an IRI with the value of
<code>http://manu.sporny.org</code>.
</p>

<p>Wrapping IRIs with the  <code>&lt;</code> and <code>&gt;</code> 
characters are only necessary when IRIs are specified as objects. At no other
point do you need to wrap an IRI. You do not need to wrap IRIs when declaring 
a property, declaring a CURIE, or describing key-value pairs in a context.</p>

</section>

<section>
<h2>Identifying the Subject</h2>

<p>A subject is declared using the <code>@</code> key. The subject is the
first piece of information needed by the JSON-LD processor in order to
create the (subject, predicate, object) tuple, also known as a triple.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "****@****": "****<http://example.org/people#joebob>****",
...
}
-->
</pre>

<p>The example above would set the subject to 
<code>&lt;http://example.org/people#joebob&gt;</code>.
</p>

</section>

<section>
<h2>Specifying the Type</h2>

<p>The type of a particular subject can be specified using the <code>a</code>
key. Specifying the type in this way will generate a triple of the form 
(subject, type, type-url).</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@": "<http://example.org/people#joebob>",
  "****a****": "****<http://xmlns.com/foaf/0.1/Person>****",
...
}
-->
</pre>

<p>The example above would generate the following triple 
(in N-Triples notation):</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/people#joebob> 
   <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
      <http://xmlns.com/foaf/0.1/Person> .
-->
</pre>

</section>

<section>
<h2>Plain Literals</h2>

<p>Regular text strings are called "plain literals" in RDF and are easily
expressed using regular JSON strings.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "foaf:name": "****Mark Birbeck****",
...
}
 -->
</pre>

</section>

<section>
<h2>Language Specification in Plain Literals</h2>

<p>JSON-LD attempts to make sure that it is easy to express triples in other
languages while simultaneously ensuring that hefty data structures 
aren't required to accomplish simple language markup. When the 
<code>@</code> symbol is used in a literal, the JSON-LD processor tags
the literal text with the language tag that follows the <code>@</code>
symbol.
</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "foaf:name": "****花澄@ja****",
...
}
 -->
</pre>

<p>The example above would generate a plain literal for <em>花澄</em> and
associate the <code>ja</code> language tag with the triple that is
generated. Languages MUST be expressed in [[!BCP47]] format.</p>

</section>

<section>
<h2>Typed Literals</h2>

<p>Literals may also be typed in JSON-LD by using the <code>^^</code>
sequence at the end of the text string.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "dc:modified": "****2010-05-29T14:17:39+02:00^^xsd:dateTime****",
...
}
 -->
</pre>

<p>The example above would generate an object with the value of
<code>2010-05-29T14:17:39+02:00</code> and the datatype of
<code>http://www.w3.org/2001/XMLSchema#dateTime</code>.</p>

</section>

<section>
<h2>Multiple Objects for a Single Property</h2>

<p>A JSON-LD author can express multiple triples in a compact way by using
arrays. If a subject has multiple values for the same property, the author
MAY express each property as an array.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@": "<http://example.org/people#joebob>",
  "foaf:nick": ****["stu", "groknar", "radface"]****,
...
}
 -->
</pre>

<p>The markup shown above would generate the following triples:</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/people#joebob> 
   <http://xmlns.com/foaf/0.1/nick>
      "stu" .
<http://example.org/people#joebob> 
   <http://xmlns.com/foaf/0.1/nick>
      "groknar" .
<http://example.org/people#joebob> 
   <http://xmlns.com/foaf/0.1/nick>
      "radface" .
-->
</pre>

</section>

<section>
<h2>Multiple Typed Literals for a Single Property</h2>

<p>Multiple typed literals are expressed very much in the same way as 
multiple properties:</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@": "<http://example.org/articles/8>",
  "dcterms:modified": ****["2010-05-29T14:17:39+02:00^^xsd:dateTime", "2010-05-30T09:21:28-04:00^^xsd:dateTime"****],
...
}
 -->
</pre>

<p>The markup shown above would generate the following triples:</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/articles/8> 
   <http://purl.org/dc/terms/modified>
      "2010-05-29T14:17:39+02:00"^^http://www.w3.org/2001/XMLSchema#dateTime .
<http://example.org/articles/8> 
   <http://purl.org/dc/terms/modified>
      "2010-05-30T09:21:28-04:00"^^http://www.w3.org/2001/XMLSchema#dateTime .
-->
</pre>

</section>

<section>
<h2>Blank Nodes</h2>

<p>At times, it becomes necessary to be able to express information without
being able to specify the subject. Typically, this is where blank nodes come
into play. In JSON-LD, blank node identifiers are automatically created if a 
subject is not specified using the <code>@</code> key. However, authors may
name blank nodes by using the special <code>_</code> CURIE prefix.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@": "****_:foo****",
...
}
 -->
</pre>

<p>The example above would set the subject to <code>_:foo</code>, which can
then be used later on in the JSON-LD markup to refer back to the 
named blank node.
</p>

</section>

<section>
<h2>Escape Character</h2>

<p>Special characters in property values MUST be escaped in order to not be 
interpreted as CURIEs, IRIs, language tags, or TypedLiterals.</p>

<p>The special characters in JSON-LD are: <code>&lt;</code>, <code>&gt;</code>,
<code>@</code>, <code>#</code>, <code>:</code> and <code>^</code>.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "example:code": ****"\\<foobar\\^\\^2\\>"****,
...
}
 -->
</pre>

</section>

<section>
<h2>Automatic Typing</h2>

<p>Since JSON is capable of expressing typed information such as decimals, 
integers and boolean values, JSON-LD utilizes that information to create 
<a href="#typed-literals">Typed Literals</a>.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  // This value is automatically converted to having a type of xsd:decimal
  "measure:cups": ****5.3****,
  // This value is automatically converted to having a type of xsd:integer
  "chem:protons": ****12****,
  // This value is automatically converted to having a type of xsd:boolean
  "sensor:active": ****true****,
...
}
 -->
</pre>

</section>

</section>

<section>
<h1>Advanced Concepts</h1>

<p class="issue">There are a few advanced concepts where it is not clear whether
or not the JSON-LD specification is going to support the complexity necessary
to support each concept. The entire section on Advanced Concepts should be
taken with a grain of salt; it is merely a list of possibilities where all
of the benefits and drawbacks have not been explored.
</p>

<section>
<h2>Disjoint Graphs</h2>

<p>When serializing an RDF graph that contains two or more sections of the
graph which are entirely disjoint, one must use an array to express the graph
as two graphs. This may not be acceptable to some authors, who would rather
express the information as one graph. Since, by definition, disjoint graphs
require there to be two top-level objects, JSON-LD utilizes a mechanism that
allows disjoint graphs to be expressed using a single graph.</p>

<p>Assume the following RDF graph:</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/people#john> 
   <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
      <http://xmlns.com/foaf/0.1/Person> .
<http://example.org/people#jane> 
   <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
      <http://xmlns.com/foaf/0.1/Person> .
-->
</pre>

<p>Since the two subjects are entirely disjoint with one another, it is
impossible to express the RDF graph above using a single JSON-LD associative
array.</p>

<p>In JSON-LD, one can use the subject to express disjoint graphs as a 
single graph:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "#": { "foaf": "http://xmlns.com/foaf/0.1/" },
  "@": 
  [
    {
      "@": "<http://example.org/people#john>",
      "a": "foaf:Person"
    },
    {
      "@": "<http://example.org/people#jane>",
      "a": "foaf:Person"
    }
  ]
}
-->
</pre>

</section>
</section>

<section class="appendix">
<h1>Acknowledgements</h1>

<p>The editor would like to thank Mark Birbeck, who provided a great deal of the
rationale and reasoning behind the JSON-LD work via his work on RDFj, 
Dave Longley who reviewed and provided feedback on the overall 
specification and contexts, and Ian Davis, who created RDF/JSON.</p>
</section>

</body>
</html>

