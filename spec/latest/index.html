<!DOCTYPE html>
<html>
<head>
<title>JSON-LD - Linked Data Expression in JSON</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- 
  === NOTA BENE ===
  For the three scripts below, if your spec resides on dev.w3 you can check them
  out in the same tree and use relative links so that they'll work offline,
  -->
<script type="text/javascript"
  src="http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js" class="remove">
 </script>
<script type="text/javascript" class="remove">

    var preProc = {
          apply:  function(c) {
                    // extend the bibliography entries
                    berjon.biblio["MICRODATA"] = "Ian Hickson; et al. <a href=\"http://www.w3.org/TR/microdata/\"><cite>Microdata</cite></a> 04 March 2010. W3C Working Draft. URL: <a href=\"http://www.w3.org/TR/microdata/\">http://www.w3.org/TR/microdata/</a> ";
                    berjon.biblio["HTML-RDFA"] = "Manu Sporny; et al. <a href=\"http://www.w3.org/TR/rdfa-in-html/\"><cite>HTML+RDFa</cite></a> 04 March 2010. W3C Working Draft. URL: <a href=\"http://www.w3.org/TR/rdfa-in-html/\">http://www.w3.org/TR/rdfa-in-html/</a> ";
                    berjon.biblio["BCP47"] = "A. Phillips, M. Davis. <a href=\"http://tools.ietf.org/rfc/bcp/bcp47.txt\"><cite>Tags for Identifying Languages</cite></a> September 2009. IETF Best Current Practice. URL: <a href=\"http://tools.ietf.org/rfc/bcp/bcp47.txt\">http://tools.ietf.org/rfc/bcp/bcp47.txt</a>";
                    berjon.biblio["RDF-API"] = "Manu Sporny, Benjamin Adrian, Nathan Rixham; et al. <a href=\"http://www.w3.org/2010/02/rdfa/sources/rdf-api/\"><cite>RDF API</cite></a> Latest. W3C Editor's Draft. URL: <a href=\"http://www.w3.org/2010/02/rdfa/sources/rdf-api/\">http://www.w3.org/2010/02/rdfa/sources/rdf-api/</a>";
                    berjon.biblio["RDF-INTERFACES"] = "Nathan Rixham, Manu Sporny, Benjamin Adrian; et al. <a href=\"http://www.w3.org/2010/02/rdfa/sources/rdf-interfaces/\"><cite>RDF Interfaces</cite></a> Latest. W3C Editor's Draft. URL: <a href=\"http://www.w3.org/2010/02/rdfa/sources/rdf-interfaces/\">http://www.w3.org/2010/02/rdfa/sources/rdf-interfaces/</a>";

                    // process the document before anything else is done
                    var refs = document.querySelectorAll('adef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'dfn' ) ;
                        var tit = item.getAttribute('title') ;
                        if (!tit) {
                            tit = con;
                        }
                        sp.className = 'adef' ;
                        sp.title=tit ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    refs = document.querySelectorAll('aref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'aref' ;
                        sp.setAttribute('title', con);
                        sp.innerHTML = '@'+con ;
                        p.replaceChild(sp, item) ;
                    }
                    // local datatype references
                    refs = document.querySelectorAll('ldtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'datatype';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // external datatype references
                    refs = document.querySelectorAll('dtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'externalDFN';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now do terms
                    refs = document.querySelectorAll('tdef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'dfn' ) ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now term references
                    refs = document.querySelectorAll('tref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }

                        var sp = document.createElement( 'a' ) ;
                        var id = item.textContent ;
                        sp.className = 'tref' ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                }
        } ;


      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          //publishDate:          "2010-04-29",
          //copyrightStart:       "2010",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "json-ld",
          subtitle:             "A Context-based JSON Serialization for Linked Data",
          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2011-05-07",
          previousMaturity:     "ED",
          previousDiffURI:      "http://json-ld.org/spec/ED/20100529/index.html",
          diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://json-ld.org/spec/latest/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS:             [
              "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
              "spec.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates" },
          ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          authors:  [
              { name: "Mark Birbeck", url: "http://webbackplane.com/",
                company: "Backplane Ltd.", companyURL: "http://webbackplane.com/" },
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
          ],
          
          // name of the WG
          wg:           "RDFa Working Group",
          
          // URI of the public WG page
          wgURI:        "",
          
          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          maxTocLevel: 3,
          preProcess: [ preProc ]
          //alternateFormats: [ {uri: "diff-20110507.html", label: "diff to previous version"} ],
      };

      function updateExample(doc, content) {
        // perform transformations to make it render and prettier
        content = content.replace(/<!--/, '');
        content = content.replace(/-->/, '');
        content = doc._esc(content);
        content = content.replace(/\*\*\*\*([^*]*)\*\*\*\*/g, '<span class="diff">$1</span>') ;
        return content ;
      }

      function updateDTD(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/!ENTITY % ([^ \t\r\n]*)/g, '!ENTITY <span class="entity">% $1</span>');
        content = content.replace(/!ELEMENT ([^ \t$]*)/mg, '!ELEMENT <span class="element">$1</span>');
        return content;
      }

      function updateSchema(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/&lt;xs:element\s+name=&quot;([^&]*)&quot;/g, '&lt;xs:element name="<span class="element" id="schema_element_$1">$1</span>"') ;
        return content;
      }

      function updateTTL(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="sh_sourceCode">' + doc._esc(content) + '</pre>';
        content = content.replace(/@prefix/g, '<span class="sh_keyword">@prefix</span>');
        return content;
      }
  </script>
<style>
.diff { font-weight:bold; color:#0a3; }
</style>
</head>

<body>
<section id="abstract">
<p>
Developers that embed structured data in their Web pages can choose among
a number of languages such as RDFa [[RDFA-CORE]], Microformats [[MICROFORMATS]] 
and Microdata [[MICRODATA]]. Each of these structured data languages, while
incompatible at the syntax level, can be easily mapped to RDF. JSON has 
proven to be a highly useful object serialization and messaging format. 
In an attempt to harmonize the representation of Linked Data in JSON, 
this specification outlines a common JSON representation format for 
Linked Data that can be used to represent objects specified via RDFa, 
Microformats and Microdata.
</p>
</section>

<section id='sotd'>
<p>This document is an experimental work in progress.</p>
<!-- <p>
This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from another
document. W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This
enhances the functionality and interoperability of the Web.
</p> -->
</section>

<section>
<h1>Introduction</h1>

<p>
JSON-LD is designed as a light-weight syntax that can be used to express 
Linked Data. It is primarily intended to be a way to express Linked Data 
in Javascript and other Web-based programming environments. It is also 
useful when building interoperable Web Services and when storing Linked 
Data in JSON-based document storage engines. It is practical and designed 
to be as simple as possible, utilizing the large number of JSON parsers 
and existing code that is in use today. It is designed to be able to 
express key-value pairs, RDF data, Microformats data, and Microdata.
That is, it supports every major Web-based structured data model in use 
today. It does not require anyone to change their JSON, but easily add 
meaning by adding context in a way that is out-of-band. The syntax is 
designed to not disturb already deployed systems running on JSON, but 
provide a smooth migration path from JSON to JSON with added
semantics. Finally, the format is intended to be fast to parse, fast to 
generate, stream-based and document-based processing compatible, and require
a very small memory footprint in order to operate.
</p>

<p>
  JSON, as specified in [[!RFC4627]], is a simple language for representing objects on the web.
  Linked Data is a way of describing content across different documents, or web resources. Web
  resources are described using <tref>IRI</tref>s, and typically are dereferencable entities that may be used
  to find more information, creating a "web of knowledge". JSON-LD is intended to be a simple
  publishing method for expressing linked data in JSON.
</p>
<section>
<h2>How to Read this Document</h2>

<p>
This document is a detailed specification for a serialization of JSON for Linked
data. The document is primarily intended for the following audiences:
</p>

<ul>
  <li>Web developers that want to understand the design decisions and 
  language syntax for JSON-LD.</li>
  <li>Software developers that want to encode Microformats, RDFa, or Microdata 
  in a way that is cross-language compatible via JSON.</li>
  <li>Software developers that want to write processors for JSON-LD.</li>
</ul>

<p>
To understand this specification you must first be familiar with JSON, 
which is detailed in [[!RFC4627]] and RDF as described in [[!RDF-CONCEPTS]].</p>
</section>

<section>
<h2>Contributing</h2>

<p>There are a number of ways that one may participate in the development of
this specification:</p>

<ul>
<li>All comments and discussion takes place on the public mailing list:
<a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a>
</li>

<li>Specification bugs and issues should be reported in the 
<a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>.</li>

<li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a> for the 
specification can be found on Github.</li>

<li>The <a href="http://webchat.freenode.net/?channels=#json-ld">#json-ld</a> 
IRC channel is available for real-time discussion on irc.freenode.net.</li>
</ul>

</section>

</section>

<section>
<h1>Design Goals and Rationale</h1>

<p>The following section outlines the design goals and rationale behind the 
JSON-LD markup language.
</p>

<section>
<h2>Goals</h2>

<p>
A number of design considerations were explored during the creation of this 
markup language:
</p>

<dl>
 <dt>Simplicity</dt>
 <dd>Developers don't need to know RDF in order to use the basic functionality
 provided by JSON-LD.</dd>
 <dt>Compatibility</dt>
 <dd>The JSON-LD markup should be 100% compatible with JSON.</dd>
 <dt>Expressiveness</dt>
 <dd>All major RDF concepts must be expressible via the JSON-LD syntax.</dd>
 <dt>Terseness</dt>
 <dd>The JSON-LD syntax must be very terse and human readable.</dd>
 <dt>Zero Edits, most of the time</dt>
 <dd>JSON-LD provides a mechanism that allows developers to specify 
 context in a way that is out-of-band. This allows organizations that have
 already deployed large JSON-based infrastructure to add meaning to their
 JSON in a way that is not disruptive to their day-to-day operations and is
 transparent to their current customers. At times, mapping JSON to 
 RDF can become difficult - in these instances, rather than having JSON-LD
 support esoteric markup, we chose not to support the use case and
 support a simplified syntax instead. So, while we strive for Zero Edits,
 it was not always possible without adding great complexity to the language.
 </dd>
 <dt>Streaming</dt>
 <dd>The format supports both document-based and stream-based processing.</dd>
</dl>
</section>

<section>
<h2>Map Terms to IRIs</h2>

<p>
  An Internationalized Resource Identifier (<tdef><abbr title="Internationalized Resource Identifier">IRI</abbr></tdef>)
  as described in [[!RFC3987]], is a mechanism for representing unique identifiers on the web. In Linked Data,
  IRIs (or URI references) are commonly used for describing entities and properties.
</p>

<p>Establishing a mechanism to map JSON values to IRIs will
help in the mapping of JSON objects to RDF. This does not mean that JSON-LD must
be restrictive in declaring a set of terms, rather, experimentation and 
innovation should be supported as part of the core design of JSON-LD. There are, 
however, a number of very small design criteria that can ensure that developers 
will generate good RDF data that will create value for the greater 
semantic web community and JSON/REST-based Web Services community.
</p>

<p>We will be using the following JSON object as the example for this section:
</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "a": "Person",
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/"
  "avatar": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>
</section>

<section>
<h3>The JSON-LD Context</h3>

<p>A context is used to allow developers to use aliases for 
<tref>IRI</tref>s. The semantic web, just like the document-based web, uses IRIs for
unambiguous identification. The idea is that these terms mean something, 
which you will eventually want to query. A context allows the expression of a number of
terms which map directly to <tref>IRI</tref>s. For example, the term <code>name</code>
may map directly to the IRI <code>http://xmlns.com/foaf/0.1/name</code>. This allows
JSON-LD documents to be constructed using common JSON syntax of using simple name/value
pairs.
</p>
<p>
To reduce the number of different terms that must be defined, JSON-LD also allows terms
to be used to expand Compact URIs (<abbr title="Compact URI">CURIE</abbr>).
The semantic web specifies this via <em>Vocabulary Documents</em>, in which a prefix is
associated with a document, and a suffix is used to create an IRI based on this vocabulary.
For example, the IRI <em>http://xmlns.com/foaf/0.1/</em> 
specifies a Vocabulary Document, and <strong>name</strong> is a term in 
that vocabulary. Join the two items together and you have an unambiguous 
identifier for a vocabulary term. The Compact URI Expression, or short-form,
is <code>foaf:name</code> and the expanded-form is
<code>http://xmlns.com/foaf/0.1/name</code>. This vocabulary term identifies
the given name for something, for example - a person's name.
</p>

<p>Developers, and machines, would be able to use this IRI (plugging it
directly into a web browser, for instance) to go to the term and get a 
definition of what the term means. Much like we can use WordNet today to 
see the 
<a href="http://wordnetweb.princeton.edu/perl/webwn?s=definition">definition</a>
of words in the English language. Machines need the same sort of 
dictionary of terms, and URIs provide a way to ensure that these terms
are unambiguous.
</p>

<p>The context provides a collection of vocabulary terms that can be used
for a JSON object.</p>
</section>

<section>
<h3>Unambiguous Identifiers for JSON</h3>
            
<p>If a set of terms, like <strong>Person</strong>, 
<strong>name</strong>, and <strong>homepage</strong>,
are defined in a context, and that context is used to resolve the
names in JSON objects, machines could automatically expand the terms to 
something meaningful and unambiguous, like this:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "****http://www.w3.org/1999/02/22-rdf-syntax-ns#type****": "****http://xmlns.com/foaf/0.1/Person****",
  "****http://xmlns.com/foaf/0.1/name****": "Manu Sporny",
  "****http://xmlns.com/foaf/0.1/homepage****": "http://manu.sporny.org"
  "****http://rdfs.org/sioc/ns#avatar****": "http://twitter.com/account/profile_image/manusporny"
}
 -->
</pre>

<p>Doing this would mean that JSON would start to become unambiguously
machine-readable, play well with the semantic web, and basic markup wouldn't 
be that much more complex than basic JSON markup. A win, all around.</p>
</section>

<section>
<h3>Mashing Up Vocabularies</h3>

<p>Developers would also benefit by allowing other vocabularies to be used
automatically with their JSON API. There are over 200 
Vocabulary Documents that are available for use on the Web today. Some
of these vocabularies are:
</p>

<ul>
   <li>RDF - for describing information about objects on the semantic web.</li>
   <li>RDFS - for expressing things like labels and comments.</li>
   <li>XSD - for specifying basic types like strings, integers, dates and times.</li>
   <li>Dublin Core - for describing creative works.</li>
   <li>FOAF - for describing social networks.</li>
   <li>Calendar - for specifying events.</li>
   <li>SIOC - for describing discussions on blogs and websites.</li>
   <li>CCrel - for describing Creative Commons and other types of licenses.</li>
   <li>GEO - for describing geographic location.</li>
   <li>VCard - for describing organizations and people.</li>
   <li>DOAP - for describing projects.</li>
</ul>

<p>Since these vocabularies are very popular, they are pre-defined in
something called the <tref>default context</tref>, which is a set of
vocabulary prefixes that are pre-loaded in all JSON-LD processors. The
contents of the <tref>default context</tref> are provided later in this 
document. Using the <tref>default context</tref> allows developers to 
express data unambiguously, like so:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "****rdf:type****": "****foaf:Person****",
  "****foaf:name****": "Manu Sporny",
  "****foaf:homepage****": "http://manu.sporny.org/",
  "****sioc:avatar****": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>

<p>Developers can also specify their own Vocabulary documents by modifying the 
<tref>active context</tref> in-line using the <code>@context</code> keyword, like so:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  ****"@context": { "myvocab": "http://example.org/myvocab#" }****,
  "a": "foaf:Person",
  "foaf:name": "Manu Sporny",
  "foaf:homepage": "http://manu.sporny.org/",
  "sioc:avatar": "http://twitter.com/account/profile_image/manusporny"****,
  "myvocab:personality": "friendly"****
}

-->
</pre>

<p>The <code>@context</code> keyword is used to change how the JSON-LD
processor evaluates key-value pairs. In this case, it was used to
map one string ('myvocab') to another string, which is interpreted as
a <tref>IRI</tref>. In the example above, the <code>myvocab</code> string is replaced 
with "<code>http://example.org/myvocab#</code>" when it
is detected. In the example above, "<code>myvocab:personality</code>" would
expand to "<code>http://example.org/myvocab#personality</code>".</p>

<p>This mechanism is a short-hand for RDF, called a CURIE, and provides
developers an unambiguous way to map any JSON value to RDF.<p>

</section>

<section>
<h3>An Example of a Context</h3>

<p>JSON-LD strives to ensure that developers don't have to change the JSON
that is going into and being returned from their Web applications. A JSON-LD 
aware Web Service MAY define a known context. For example, the
following <tref>default context</tref> could apply to all incoming Web Service calls
previously accepting only JSON data:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": 
  {
    "@vocab": "http://example.org/default-vocab#",
    "@base": "http://example.org/baseurl/",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dc": "http://purl.org/dc/terms/",
    "foaf": "http://xmlns.com/foaf/0.1/",
    "sioc": "http://rdfs.org/sioc/ns#",
    "cc": "http://creativecommons.org/ns#",
    "geo": "http://www.w3.org/2003/01/geo/wgs84_pos#",
    "vcard": "http://www.w3.org/2006/vcard/ns#",
    "cal": "http://www.w3.org/2002/12/cal/ical#",
    "doap": "http://usefulinc.com/ns/doap#",
    "Person": "http://xmlns.com/foaf/0.1/Person",
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": "http://xmlns.com/foaf/0.1/homepage"
    "@coerce": 
    {
      "xsd:anyURI": ["rdf:type", "rdf:rest", "foaf:homepage", "foaf:member"],
      "xsd:integer": "foaf:age"
    }
  }
}
-->
</pre>

<p>The <code>@vocab</code> string is a special keyword that states 
that any term that doesn't resolve to a term or a prefix should be 
appended to the <code>@vocab</code> IRI. This is done to ensure that 
terms can be transformed to an IRI at all times.
</p>

<p>The <code>@base</code> string is a special keyword that states 
that any relative IRI MUST be appended to the string specified by
<code>@base</code>.
</p>

<p>The <code>@coerce</code> keyword is used to specify type coercion
rules for the data. For each key in the map, the key is the type to
be coerced to and the value is the vocabulary term to be coerced.
Type coercion for the key <code>xsd:anyURI</code> asserts that all 
vocabulary terms listed should undergo coercion to an IRI, including
<code>@base</code> processing for relative IRIs and CURIE processing
for compact URI Expressions such as <code>foaf:homepage</code>.
</p>

</section>
</section>

<section>
<h2>Markup Examples</h2>

<p>The JSON-LD markup examples below demonstrate how JSON-LD can be used to
express semantic data marked up in other languages such as RDFa, Microformats,
and Microdata. These sections are merely provided as proof that JSON-LD is
very flexible in what it can express across different Linked Data approaches.
</p>

<section>
<h3>RDFa</h3>

<p>The following example describes three people with their respective names and
homepages.</p>

<pre class="example" data-transform="updateExample">
<!--
<div ****prefix="foaf: http://xmlns.com/foaf/0.1/"****>
   <ul>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/bob/" property="foaf:name" ****>Bob</a>
      </li>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/eve/" property="foaf:name" ****>Eve</a>
      </li>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/manu/" property="foaf:name" ****>Manu</a>
      </li>
   </ul>
</div>
-->
</pre>

<p>An example JSON-LD implementation is described below, however, there are
other ways to mark-up this information such that the context is not
repeated.</p>

<pre class="example" data-transform="updateExample">
<!--
[
 {
   "@": "_:bnode1",
   "a": "foaf:Person",
   "foaf:homepage": "http://example.com/bob/",
   "foaf:name": "Bob"
 },
 {
   "@": "_:bnode2",
   "a": "foaf:Person",
   "foaf:homepage": "http://example.com/eve/",
   "foaf:name": "Eve"
 },
 {
   "@": "_:bnode3",
   "a": "foaf:Person",
   "foaf:homepage": "http://example.com/manu/",
   "foaf:name": "Manu"
 }
]
-->
</pre>

</section>

<section>
<h3>Microformats</h3>

<p>The following example uses a simple Microformats hCard example to express
how the Microformat is represented in JSON-LD.</p>

<pre class="example" data-transform="updateExample">
<!--
<div class="vcard">
 <a class="url fn" href="http://tantek.com/">Tantek Çelik</a>
</div>
-->
</pre>

<p>The representation of the hCard expresses the Microformat terms in the
context and uses them directly for the <code>url</code> and <code>fn</code>
properties. Also note that the Microformat to JSON-LD processor has 
generated the proper URL type for <code>http://tantek.com</code>.</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": 
  {
    "vcard": "http://microformats.org/profile/hcard#vcard",
    "url": "http://microformats.org/profile/hcard#url",
    "fn": "http://microformats.org/profile/hcard#fn",
    "@coerce": { "xsd:anyURI": "url" }
  },
  "@": "_:bnode1",
  "a": "vcard",
  "url": "http://tantek.com/",
  "fn": "Tantek Çelik"
}
-->
</pre>

</section>

<section>
<h3>Microdata</h3>

<p>The Microdata example below expresses book information as a Microdata Work
item.
</p>

<pre class="example" data-transform="updateExample">
<!--
<dl itemscope
    itemtype="http://purl.org/vocab/frbr/core#Work"
    itemid="http://purl.oreilly.com/works/45U8QJGZSQKDH8N">
 <dt>Title</dt>
 <dd><cite itemprop="http://purl.org/dc/terms/title">Just a Geek</cite></dd>
 <dt>By</dt>
 <dd><span itemprop="http://purl.org/dc/terms/creator">Wil Wheaton</span></dd>
 <dt>Format</dt>
 <dd itemprop="http://purl.org/vocab/frbr/core#realization"
     itemscope
     itemtype="http://purl.org/vocab/frbr/core#Expression"
     itemid="http://purl.oreilly.com/products/9780596007683.BOOK">
  <link itemprop="http://purl.org/dc/terms/type" href="http://purl.oreilly.com/product-types/BOOK">
  Print
 </dd>
 <dd itemprop="http://purl.org/vocab/frbr/core#realization"
     itemscope
     itemtype="http://purl.org/vocab/frbr/core#Expression"
     itemid="http://purl.oreilly.com/products/9780596802189.EBOOK">
  <link itemprop="http://purl.org/dc/terms/type" href="http://purl.oreilly.com/product-types/EBOOK">
  Ebook
 </dd>
</dl>
-->
</pre>

<p>Note that the JSON-LD representation of the Microdata information stays
true to the desires of the Microdata community to avoid contexts and
instead refer to items by their full IRI.</p>

<pre class="example" data-transform="updateExample">
<!--
[
  {
    "@": "http://purl.oreilly.com/works/45U8QJGZSQKDH8N",
    "a": "http://purl.org/vocab/frbr/core#Work",
    "http://purl.org/dc/terms/title": "Just a Geek",
    "http://purl.org/dc/terms/creator": "Whil Wheaton",
    "http://purl.org/vocab/frbr/core#realization": 
      ["http://purl.oreilly.com/products/9780596007683.BOOK", "http://purl.oreilly.com/products/9780596802189.EBOOK"]
  },
  {
    "@": "http://purl.oreilly.com/products/9780596007683.BOOK",
    "a": "http://purl.org/vocab/frbr/core#Expression",
    "http://purl.org/dc/terms/type": "http://purl.oreilly.com/product-types/BOOK"
  },
  {
    "@": "http://purl.oreilly.com/products/9780596802189.EBOOK",
    "a": "http://purl.org/vocab/frbr/core#Expression",
    "http://purl.org/dc/terms/type": "http://purl.oreilly.com/product-types/EBOOK"
  }
]
-->
</pre>
</section>
</section>

<section>
<h1>Markup of RDF Concepts</h1>

<p>JSON-LD is designed to ensure that most Linked Data concepts can be marked 
up in a way that is simple to understand and author by Web developers. In many
cases, Javascript objects can become Linked Data with the simple addition
of a context. Since RDF is also an important sub-community of the Linked
Data movement, it is important that all RDF concepts are well-represented
in this specification. This section details how each RDF concept can be
expressed in JSON-LD.</p>

<section>
<h2>IRIs</h2>

<p>Expressing IRIs are fundamental to Linked Data as that is how most subjects
and many objects are identified. IRIs can be expressed in a variety of
different ways in JSON-LD.</p>

<ol>
  <li>In general, an IRI is generated if it is in the key position in 
    an associative array. There are special rules for processing keys in
    <code>@context</code> and when dealing with keys that start with the
    <code>@</code> character.</li>
  <li>An IRI is generated for the value specified using <code>@</code>, if
    it is a string.</li>
  <li>An IRI is generated for the value specified using <code>a</code>.</li>
  <li>An IRI is generated for the value specified using the <code>@iri</code> 
    keyword.</li>
  <li>An IRI is generated when there are <code>@coerce</code> rules in 
    effect for <code>xsd:anyURI</code> for a particular vocabulary term.</li>
</ol>

<p>An example of IRI generation for a key outside of a <code>@context</code>:
</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "****http://xmlns.com/foaf/0.1/name****": "Manu Sporny",
...
}
-->
</pre>

<p>In the example above, the key 
<code>http://xmlns.com/foaf/0.1/name</code> is interpreted as an IRI, as 
opposed to being interpreted as a string..</p>

<p>Term expansion occurs for IRIs if a term is defined within the <tref>active context</tref>:</p>
<pre class="example" data-transform="updateExample">
<!--
{
  "****@context****": {"****name****": "****http://xmlns.com/foaf/0.1/name****"},
...
  "****name****": "Manu Sporny",
...
}
-->
</pre>

<p>CURIE expansion also occurs for keys in JSON-LD:</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "****foaf:name****": "Manu Sporny",
...
}
-->
</pre>

<p><code>foaf:name</code> above will automatically expand out to the IRI
<code>http://xmlns.com/foaf/0.1/name</code>.</p>

<p>An IRI is generated when a value is associated with a key using 
the <code>@iri</code> keyword:</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "foaf:homepage": { "****@iri****": "http://manu.sporny.org" }
...
}
-->
</pre>

<p>If type coercion rules are specified in the <code>@context</code> for
a particular vocabulary term, an IRI is generated:</p>

<pre class="example" data-transform="updateExample">
<!--
{****
  "@context": 
  { 
    "@coerce": 
    {
      "xsd:anyURI": "foaf:homepage"
    } 
  }****
...
  "foaf:homepage": "http://manu.sporny.org",
...
}
-->
</pre>

</section>

<section>
<h2>Identifying the Subject</h2>

<p>A subject is declared using the <code>@</code> key. The subject is the
first piece of information needed by the JSON-LD processor in order to
create the (subject, property, object) tuple, also known as a triple.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "****@****": "****http://example.org/people#joebob****",
...
}
-->
</pre>

<p>The example above would set the subject to the IRI 
<code>http://example.org/people#joebob</code>.
</p>

</section>

<section>
<h2>Specifying the Type</h2>

<p>The type of a particular subject can be specified using the <code>a</code>
key. Specifying the type in this way will generate a triple of the form 
(subject, type, type-url).</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@": "http://example.org/people#joebob",
  "****a****": "****http://xmlns.com/foaf/0.1/Person****",
...
}
-->
</pre>

<p>The example above would generate the following triple 
(in N-Triples notation):</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/people#joebob> 
   <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
      <http://xmlns.com/foaf/0.1/Person> .
-->
</pre>

</section>

<section>
<h2>Plain Literals</h2>

<p>Regular text strings are called a <tdef>plain literal</tdef> in RDF and are easily
expressed using regular JSON strings.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "foaf:name": "****Mark Birbeck****",
...
}
 -->
</pre>

</section>

<section>
<h2>Language Specification in Plain Literals</h2>

<p>JSON-LD makes an assumption that <tref>plain literal</tref>s with associated
language encoding information is not very common when used in
JavaScript and Web Services. Thus, it takes a little more
effort to express plain literals in a specified language.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "foaf:name": ****
  {
    "@literal": "花澄",
    "@language": "ja"
  }****
...
}
-->
</pre>

<p>The example above would generate a <tref>plain literal</tref> for <em>花澄</em> and
associate the <code>ja</code> language tag with the triple that is
generated. Languages MUST be expressed in [[!BCP47]] format.</p>

</section>

<section>
<h2>Typed Literals</h2>

<p>
  A <tdef>typed literal</tdef> is indicated by attaching a IRI to the end of a <tref>plain literal</tref>, and this
  IRI indicates the literal's datatype. Literals may be typed in JSON-LD in three ways:
</p>

<ol>
  <li>By utilizing the <code>@coerce</code> keyword.</li>
  <li>By utilizing the expanded form for specifying objects.</li>
  <li>By using a native JSON datatype.</li>
</ol>

<p>The first example uses the <code>@coerce</code> keyword to express a
typed literal:</p>

<pre class="example" data-transform="updateExample">
<!--
{****
  "@context": 
  { 
    "@coerce": 
    {
      "xsd:dateTime": "dc:modified"
    }
  }****
...
  "dc:modified": "2010-05-29T14:17:39+02:00",
...
}
-->
</pre>

<p>The second example uses the expanded form for specifying objects:</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "dc:modified": ****
  {
    "@literal": "2010-05-29T14:17:39+02:00",
    "@datatype": "xsd:dateTime"
  }****
...
}
-->
</pre>

<p>Both examples above would generate an object with the literal value of
<code>2010-05-29T14:17:39+02:00</code> and the datatype of
<code>http://www.w3.org/2001/XMLSchema#dateTime</code>.</p>

</section>

<section>
<h2>Multiple Objects for a Single Property</h2>

<p>A JSON-LD author can express multiple triples in a compact way by using
arrays. If a subject has multiple values for the same property, the author
MAY express each property as an array.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@": "http://example.org/people#joebob",
  "foaf:nick": ****["joe", "bob", "jaybee"]****,
...
}
-->
</pre>

<p>The markup shown above would generate the following triples:</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/people#joebob> 
   <http://xmlns.com/foaf/0.1/nick>
      "joe" .
<http://example.org/people#joebob> 
   <http://xmlns.com/foaf/0.1/nick>
      "bob" .
<http://example.org/people#joebob> 
   <http://xmlns.com/foaf/0.1/nick>
      "jaybee" .
-->
</pre>

</section>

<section>
<h2>Multiple Typed Literals for a Single Property</h2>

<p>Multiple <tref>typed literal</tref>s may also be expressed using the expanded
form for objects:</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@": "http://example.org/articles/8",
  "dcterms:modified": ****
  [
    {
      "@literal": "2010-05-29T14:17:39+02:00",
      "@datatype": "xsd:dateTime"
    },
    {
      "@literal": "2010-05-30T09:21:28-04:00",
      "@datatype": "xsd:dateTime"
    }
  ]****
...
}
-->
</pre>

<p>The markup shown above would generate the following triples:</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/articles/8> 
   <http://purl.org/dc/terms/modified>
      "2010-05-29T14:17:39+02:00"^^http://www.w3.org/2001/XMLSchema#dateTime .
<http://example.org/articles/8> 
   <http://purl.org/dc/terms/modified>
      "2010-05-30T09:21:28-04:00"^^http://www.w3.org/2001/XMLSchema#dateTime .
-->
</pre>

</section>

<section>
<h2>Blank Nodes</h2>

<p>At times, it becomes necessary to be able to express information without
being able to specify the subject. Typically, this is where blank nodes come
into play. In JSON-LD, blank node identifiers are automatically created if a 
subject is not specified using the <code>@</code> keyword. However, authors 
may name blank nodes by using the special <code>_</code> CURIE prefix.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@": "****_:foo****",
...
}
 -->
</pre>

<p>The example above would set the subject to <code>_:foo</code>, which can
then be used later on in the JSON-LD markup to refer back to the 
named blank node.
</p>

</section>
</section>

<section>
<h1>Advanced Features</h1>

<p>JSON-LD has a number of features that provide functionality above and beyond
the core functionality provided by RDF. The following sections outline the
features that are specific to JSON-LD.
</p>

<section>
<h2>Automatic Typing</h2>

<p>Since JSON is capable of expressing typed information such as doubles, 
integers, and boolean values. As demonstrated below, JSON-LD utilizes that 
information to create <tref>typed literal</tref>s:</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  // The following two values are automatically converted to a type of xsd:double
  // and both values are equivalent to each other.
  "measure:cups": ****5.3****,
  "measure:cups": ****5.3e0****,
  // The following value is automatically converted to a type of xsd:double as well
  "space:astronomicUnits": ****6.5e73****,
  // The following value should never be converted to a language-native type
  "measure:stones": ****{ "@literal": "4.8", "@datatype": "xsd:decimal" }****,
  // This value is automatically converted to having a type of xsd:integer
  "chem:protons": ****12****,
  // This value is automatically converted to having a type of xsd:boolean
  "sensor:active": ****true****,
...
}
-->
</pre>

<p class="note">When dealing with a number of modern programming languages,
including JavaScript ECMA-262, there is no distinction between 
<strong>xsd:decimal</strong> and <strong>xsd:double</strong> values. That is, 
the number <code>5.3</code> and the number 
<code>5.3e0</code> are treated as if they were the same. When converting from 
JSON-LD to a language-native format and back, datatype information is lost in a 
number of these languages. Thus, one could say that <code>5.3</code> is a 
<strong>xsd:decimal</strong> and <code>5.3e0</code> is an 
<strong>xsd:double</strong> in JSON-LD, but when both values are 
converted to a language-native format the datatype difference between the two 
is lost because the machine-level representation will almost always be a 
<strong>double</strong>. 
Implementers should be aware of this potential round-tripping issue between 
<strong>xsd:decimal</strong> and <strong>xsd:double</strong>. Specifically
objects with a datatype of <strong>xsd:decimal</strong> MUST NOT be converted
to a language native type.
</p>

</section>

<section>
<h2>Type Coercion</h2>

<p>JSON-LD supports the coercion of types to ensure that the zero-edit goal of
JSON-LD can be accomplished. Type coercion allows someone deploying JSON-LD to
coerce and incoming or outgoing types to the proper RDF type based on a
mapping of type IRIs to RDF types. Using type conversion, one may convert
simple JSON data to properly typed RDF data.</p>

<p>The example below demonstrates how a JSON-LD author can coerce values to 
<tref>plain literal</tref>s, <tref>typed literal</tref>s and IRIs.</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": 
  {  
     "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
     "xsd": "http://www.w3.org/2001/XMLSchema#",
     "name": "http://xmlns.com/foaf/0.1/name",
     "age": "http://xmlns.com/foaf/0.1/age",
     "homepage": "http://xmlns.com/foaf/0.1/homepage",
****     "@coerce":
     {
        "xsd:integer": "age",
        "xsd:anyURI": "homepage",
     }****
  },
  "name": "John Smith",
  "age": ****"41"****,
  "homepage": ****"http://example.org/home/"****
}
-->
</pre>

<p>The example above would generate the following triples:</p>

<pre class="example" data-transform="updateExample">
<!--
_:bnode1
   <http://xmlns.com/foaf/0.1/name>
      "John Smith" .
_:bnode1
   <http://xmlns.com/foaf/0.1/age>
      "41"^^http://www.w3.org/2001/XMLSchema#integer .
_:bnode1
   <http://xmlns.com/foaf/0.1/homepage>
      <http://example.org/home/> .
-->
</pre>

</section>
</section>

<section>
<h3>The JSON-LD Processing Algorithm</h3>
<p>
  The JSON-LD Processing Model describes processing rules for extracting RDF
  from a JSON-LD document. Note that many uses of JSON-LD may not require generation of RDF.
</p>

<p>
The processing algorithm described in this section is provided in
order to demonstrate how one might implement a JSON-LD processor. 
Conformant implementations are only required to produce the same type and
number of triples during the output process and are not required to 
implement the algorithm exactly as described.
</p>

<p class="issue">The Processing Algorithm is a work in progress.</p>

<section class="informative">
  <h4>Overview</h4>
  <p>
    JSON-LD is intended to have an easy to parse grammar that closely models existing
    practice in using JSON for describing object representations. This allows the use
    of existing libraries for parsing JSON in a document-oriented fashion, or can allow
    for stream-based parsing similar to SAX.
  </p>
  <p>
    As with other grammars used for describing linked data, a key concept is that of
    a <em>resource</em>. Resources may be of three basic types: <em>IRI</em>s, for describing
    externally named entities, <em>BNodes</em>, resources for which an external name does not
    exist, or is not known, and Literals, which describe terminal entities such as strings,
    dates and other representations having a lexical representation possibly including
    an explicit language or datatype.
  </p>
  <p>
    Data described with JSON-LD may be considered to be the representation of a graph made
    up of <em>subject</em> and <em>object</em> resources related via a <em>predicate</em> resource.
    However, specific implementations may choose to operate on the document as a normal
    JSON description of objects having attributes.
  </p>
</section>

<section>
  <h4>Processing Algorithm Terms</h4>
  <dl>
    <dt><tdef>default context</tdef></dt>
    <dd>
      a context that is specified to the JSON-LD processing algorithm
      before processing begins.
    </dd>
    <dt><tdef>default graph</tdef></dt>
    <dd>
      the destination graph for all triples generated by JSON-LD markup.
    </dd>
    <dt><tdef>active subject</tdef></dt>
    <dd>
      the currently active subject that the processor should use when
      generating triples.
    </dd>
    <dt><tdef>active property</tdef></dt>
    <dd>
      the currently active property that the processor should use when
      generating triples.
    </dd>
    <dt><tdef>active object</tdef></dt>
    <dd>
      the currently active object that the processor should use when
      generating triples.
    </dd>
    <dt><tdef>active context</tdef></dt>
    <dd>
      a context that is used to resolve CURIEs while the processing
      algorithm is running. The <tref>active context</tref> is the context contained within the
      <tref>processor state</tref>.
    </dd>
    <dt><tdef>local context</tdef></dt>
    <dd>
      a context that is specified at the JSON associative-array level,
      specified via the <code>@context</code> keyword.
    </dd>
    <dt><tdef>processor state</tdef></dt>
    <dd>
      the <tref>processor state</tref>, which includes the <tref>active
      context</tref>, <tref>current subject</tref>, and <tref>current property</tref>. The <tref>processor
      state</tref> is managed as a stack with elements from the previous <tref>processor state</tref>
      copied into a new <tref>processor state</tref> when entering a new associative array.
    </dd>
  </dl>
</section>

<section>
  <h4>Processing Tokens and Keywords</h4>
  <dl>
  <dt><code>@context</code></dt><dd>Used to set the <tref>local context</tref>.</dd>
  <dt><code>@base</code></dt><dd>Used to set the base IRI for all object IRIs affected  by the <tref>active context</tref>.</dd>
  <dt><code>@profile</code></dt><dd>A reference to a remote context description used to set the <tref>local context</tref>.</dd>
  <dt><code>@vocab</code></dt><dd>Used to set the base IRI for all property IRIs affected by the <tref>active context</tref>.</dd>
  <dt><code>@coerce</code></dt><dd>Used to specify type coercion rules.</dd>
  <dt><code>@literal</code></dt><dd>Used to specify a literal value.</dd>
  <dt><code>@iri</code></dt><dd>Used to specify an IRI value.</dd>
  <dt><code>@language</code></dt><dd>Used to specify the language for a literal.</dd>
  <dt><code>@datatype</code></dt><dd>Used to specify the datatype for a literal.</dd>
  <dt><code>:</code></dt><dd>The separator for CURIEs when used in JSON keys or JSON values.</dd>
  <dt><code>@</code></dt><dd>Sets the active subjects.</dd>
  <dt><code>a</code></dt><dd>Used to set the rdf:type of the active subjects. This token may be conferred as syntactic sugar for rdf:type.</dd>
  </dl>
  <p class="issue">Use <code>@source</code> instead of <code>@</code>?</p>
  <p class="issue">Use <code>@type</code> instead of <code>a</code>? Note that both are just semantic sugar for <code>rdf:type</code>.</p>
</section>

<section>
  <h4>Context</h4>
  <p>
    Processing of JSON-LD is managed recursively using a process described in <a href="sequence">Sequence</a>.
    During processing, each rule is applied using information provided by the <tref>active context</tref>.
    Processing begins by pushing a new <tref>processor state</tref> onto the <tref>processor state</tref> stack and
    initializing the <tref>active context</tref> with the <tref>default context</tref>. If a <tref>local context</tref> is encountered,
    information from the <tref>local context</tref> is merged into the <tref>active context</tref>.
  </p>
  <p class="issue">Should the document URL be used as the default for <code>@base</code> in the <tref>default context</tref>?</p>
  <p>
    The <tref>active context</tref> is used for expanding keys and values of an associative array (or elements
    of a list (see <span a="#list-processing">List Processing</span>)).
  </p>
  <p>
    A <tref>local context</tref> is identified within an associative array having a key of <code>@context</code> with an associative
    array value. When processing a <tref>local context</tref>, special rules apply:
  </p>
  <ul>
    <li>The key <code>@base</code> MUST have a value of a simple string with the lexical
    form of IRI and is saved in the <tref>active context</tref> to perform term mapping as described in <a
    href="#iri-processing">IRI Processing</a>.</li>
    <li>The key <code>@vocab</code> MUST have a value of a simple string with the lexical
    form of IRI and is saved in the <tref>active context</tref> to perform term mapping as described in <a
    href="#iri-processing">IRI Processing</a>.</li>
    <li>The key <code>@coerce</code> MUST have a value of an associative array. Processing
      of the associative array is described <a href="#coerce">below</a></li>
    <li>Otherwise, the key MUST have the lexical form of
      <cite><a href="http://www.w3.org/TR/2009/REC-xml-names-20091208/#NT-NCName">NCName</a></cite>
      and MUST have the value of a simple string with the lexical form of IRI.
      Merge each key-value pair into the <tref>active context</tref>, overwriting
      any duplicate values.
    </li>
  </ul>
  <p>A <tref>local context</tref> may also be loaded from an external document using the <code>@profile</code>
    key as described in <a href="#vocabulary-profiles">Vocabulary Profiles</a>.
  </p>
  <section>
    <h5>Coerce</h5>
    <p>
      Map each key-value pair in the <tref>local context</tref>'s
      <code>@coerce</code> mapping into the <tref>active context</tref>'s
      <code>@coerce</code> mapping, overwriting any duplicate values in 
      the <tref>active context</tref>'s <code>@coerce</code> mapping.
      The <code>@coerce</code> mapping has a either of a single CURIE or of an
      array of CURIEs. When merging with an existing mapping in the <tref>active context</tref>,
      map all CURIE values to array form and replace with the union of the value from
      the <tref>local context</tref> and the value of the <tref>active context</tref>. If the result is an array
      with a single CURIE, the processor MAY represent this as a string value.
    </p>
  </section>
</section>

<section>
  <h4>Chaining</h4>
  <p>
    Object <tdef>chaining</tdef> is a JSON-LD feature that allows an author to use the definition
    of JSON-LD objects as <tref>property</tref> values. This is a commonly used mechanism for
    creating a parent-child relationship between objects.
  </p>
  <p>The example shows an two objects related by a property from the first object:</p>

  <pre class="example" data-transform="updateExample">
  <!--
  {
  ...
    "foaf:name": "Manu Sporny",
    "****foaf:knows****": {
      "****a****": "****foaf:Person****",
      "****foaf:name****": "****Gregg Kellogg****",
    }
  ...
  }
  -->
  </pre>
  
  <p>
    An object definition may be used anyplace a value is legal in JSON-LD.
  </p>
</section>

<section>
  <h4>IRI Processing</h4>
  <p>Keys and some values are evaluated to produce an IRI. This section defines an algorithm for
    transforming a value representing an IRI into an actual IRI.</p>
  <p>IRIs may be represented as an explicit string, or as a CURIE, as a value relative to <code>@base</code>
    or <code>@vocab</code>.</p>
  <p>
    CURIEs are defined more formally in [[RDFA-CORE]] <cite><a href="http://www.w3.org/TR/rdfa-core/#s_curies">section 6 &quot;CURIE Syntax Definition&quot;</a></cite>.
    Generally, a CURIE is composed of a <em>prefix</em> and a <em>suffix</em> separated by a ':'. In
    JSON-LD, either the prefix may be the empty string, denoting the <tdef>default prefix</tdef>.
  </p>
  <p>The procedure for generating an IRI is:
    <ol class="algorithm">
      <li>Split the value into a <em>prefix</em> and <em>suffix</em> from the first occurrence of ':'.</li>
      <li>If the prefix is a '_', generate a named BNode using the suffix as the name.</li>
      <li>If the <tref>active context</tref> contains a mapping for <em>prefix</em>, generate an IRI
        by prepending the mapped prefix to the (possibly empty) suffix. Note that an empty
        suffix and no suffix (meaning the value contains no ':' string at all) are treated equivalently.</li>
      <li>If the IRI being processed is for a property (i.e., a key value in an associative array, or a
        value in a <code>@coerce</code> mapping) and the active context has a <code>@vocab</code> mapping,
        join the mapped value to the suffix using the method described in [[!RFC3987]].</li>
      <li>If the IRI being processed is for a subject or object (i.e., not a property) and the active context has a <code>@base</code> mapping,
        join the mapped value to the suffix using the method described in [[!RFC3987]].</li>
      <li>Otherwise, use the value directly as an IRI.</li>
    </ol>
  </p>
  </section>
</section>

</section>

<section>
  <h3>Sequence</h3>

  <p>
    The algorithm below is designed for in-memory implementations with random access to associative
    array elements. For a description of a streaming implementation, see <a
    href="streaming-processors">Appendix B</a>.
  </p>
  <p>
    A conforming JSON-LD processor MUST implement a
    processing algorithm that results in the same <tref>default graph</tref> that the following
    algorithm generates:
  </p>

  <ol class="algorithm">
    <li id="processing-step-default-context">
      Create a new <tref>processor state</tref> with with the <tref>active context</tref> set to the
      <tref>default context</tref> and <tref>active subject</tref> and <tref>active property</tref>
      initialized to NULL.
    </li>

    <li id="processing-step-associative">
      If an associative array is detected, perform the following steps:
      <ol class="algorithm">
        <li>
          If the associative array has a <code>@context</code> key, process the local context as
          described in <a href="context">Context</a>.
        </li>
        <li>
          If the associative array has an <code>@iri</code> key, set the <tref>active object</tref> by
          performing <a href="#iri-processing">IRI Processing</a> on the associated value. Generate a
          triple representing the <tref>active subject</tref>, the <tref>active property</tref> and the
          <tref>active object</tref>. Return the <tref>active object</tref> to the calling location.
        </li>
        <li>
          If the associative array has a <code>@literal</code> key, set the <tref>active object</tref>
          to a literal value as follows:
          <ul>
            <li>
              as a <tref>typed literal</tref> if the associative array contains a <code>@datatype</code> key
              after performing <a href="#iri-processing">IRI Processing</a> on the specified<code>@datatype</code>.
            </li>
            <li>
              otherwise, as a <tref>plain literal</tref>. If the associative array contains
              a <code>@language</code> key, use it's value to set the language of the plain literal.
            </li>
          </ul>
          Generate a triple representing the <tref>active subject</tref>, the <tref>active
          property</tref> and the <tref>active object</tref>. Return the <tref>active object</tref> to the calling location.
        </li>
        <li>If the associative array has a <code>@</code> key:
          <ol class="algorithm">
            <li>
              If the value is a string, set the <tref>active object</tref> to the result of performing
              <a href="#iri-processing">IRI Processing</a>. Generate a
              triple representing the <tref>active subject</tref>, the <tref>active property</tref> and the
              <tref>active object</tref>. Set the <tref>active subject</tref> to the <tref>active object</tref>.
            </li>
            <li>
              Create a new <tref>processor state</tref> using copies of the <tref>active context</tref>,
              <tref>active subject</tref> and <tref>active property</tref> and process the value
              starting at <a href="#processing-step-associative">Step 2</a>, set the <tref>active
              subject</tref> to the result and proceed using the previous <tref>processor state</tref>.
            </li>
          </ol>
        </li>
        <li>
          If the associative array does not have a <code>@</code> key, set the <tref>active
          object</tref> to newly generated <tref>blank node identifier</tref>. Generate a triple
          representing the <tref>active subject</tref>, the <tref>active property</tref> and the
          <tref>active object</tref>. Set the <tref>active subject</tref> to the <tref>active
          object</tref>.
        </li>
        <li>
          For each key in the associative array that has not already been processed, perform
          the following steps:
          <ol class="algorithm">
            <li>If the key is <code>a</code>, set the <tref>active property</tref> 
            to <code>rdf:type</code>.
            </li>
            <li>Otherwise, set the <tref>active property</tref> to the result of performing
            <a href="#iri-processing">IRI Processing</a> on the key.</li>
            <li>
              Create a new <tref>processor state</tref> copies of the <tref>active context</tref>,
              <tref>active subject</tref> and <tref>active property</tref> and process the value
              starting at <a href="#processing-step-associative">Step 2</a> and proceed using the
              previous <tref>processor state</tref>.
            </li>
          </ol>
        </li>
        <li>
          Return the <tref>active object</tref> to the calling location.
        </li>
      </ol>
    </li>

    <li>
      If a regular array is detected, process each value in the array by doing the following
      returning the result of processing the last value in the array:

      <ol class="algorithm">
        <li>
          If the value is a regular array, generate an RDF List by linking
          each element of the list using <code>rdf:first</code> and <code>rdf:next</code>, terminating the list with <code>rdf:nil</code>
          using the following sequence:
          <ol>
            <li>
              If the list has no element, generate a triple using the <tref>active subject</tref>, <tref>active property</tref>
              and <code>rdf:nil</code>.
            </li>
            <li>
              Otherwise, generate a triple using using the <tref>active subject</tref>, <tref>active property</tref>
              and a newly generated BNode identified as <em>first bnode</em>.
            </li>
            <li>
              For each element other than the last element in the list:
              <ol>
                <li>Create a processor state using the active context, <em>first bnode</em> as the <tref>active subject</tref>, and <code>rdf:first</code> as the <tref>active property</tref>.</li>
                <li>Unless this is the last element in the list, generate a new BNode identified as <em>rest bnode</em>, otherwise use <code>rdf:nil</code>.</li>
                <li>Generate a new triple using <em>first bnode</em>, <code>rdf:rest</code> and <em>rest bnode</em>.</li>
                <li>Set <em>first bnode</em> to <em>rest bnode</em>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          Otherwise, create a new <tref>processor state</tref> copies of the <tref>active context</tref>,
          <tref>active subject</tref> and <tref>active property</tref> and process the value
          starting at <a href="#processing-step-associative">Step 2</a> and proceed using the
          previous <tref>processor state</tref>.
        </li>
      </ol>
    </li>
    
    <li>
      If a string is detected, generate a triple using the <tref>active subject</tref>, <tref>active object</tref>
      and a <tref>plain literal</tref> value created from the string.
    </li>
    
    <li>
      If a number is detected, generate a <tref>typed literal</tref> using a string representation of
      the value with datatype set to either <code>xsd:integer</code> or
      <code>xsd:double</code>, depending on if the value contains a
      fractional and/or an exponential component. Generate a triple using the <tref>active
      subject</tref>, <tref>active object</tref> and the generated typed literal.
    </li>
    
    <li>
      Otherwise, if <strong>true</strong> or <strong>false</strong> is detected,
      generate a triple using the <tref>active subject</tref>, <tref>active object</tref>
      and a <tref>typed literal</tref> value created from the string representation of the
      value with datatype set to <code>xsd:boolean</code>.
    </li>
  </ol>
</section>

<section>
<h1>Best Practices</h1>

<p>The nature of Web programming allows one to use basic technologies, such as
JSON-LD, across a variety of systems and environments. This section attempts to
describe some of those environments and the way in which JSON-LD can be 
integrated in order to help alleviate certain development headaches.
</p>

<section>
<h2>JavaScript</h2>

<p class="issue">It is expected that JSON-LD will be used quite a bit in 
JavaScript environments, however, features like the expanded form for
object values mean that using JSON-LD directly in JavaScript may be 
annoying without a middleware layer such as a simple library that 
converts JSON-LD markup before JavaScript uses it. One could say that JSON-LD
is a good fit for the RDF API, which enables a variety of RDF-based
Web Applications, but some don't want to require that level of functionality 
just to use JSON-LD. The group is still discussing the best way to proceed, 
so input on how JSON-LD could more easily be utilized in JavaScript 
environments would be very much appreciated.
</p>
</section>

<section>
<h2>Schema-less Databases</h2>

<p class="issue">Databases such as CouchDB and MongoDB allow the creation of
schema-less data stores. RDF is a type of schema-less data model and thus
lends itself to databases such as CouchDB and MongoDB. Both of these databases
can use JSON-LD as their storage format. The group needs feedback from 
CouchDB and MongoDB experts regarding the usefulness of JSON-LD in those
environments.</p>

<p class="issue">MongoDB does not allow the '.' character to be used in
key names. This prevents developers from storing IRIs as keys, which also
prevents storage of the data in normalized form. While this issue can
be avoided by using CURIEs for key values, it is not known if this
mechanism is enough to allow JSON-LD to be used in MongoDB in a way that
is useful to developers.
</p>

</section>

</section>

<section>
<h1>Advanced Concepts</h1>

<p class="issue">There are a few advanced concepts where it is not clear 
whether or not the JSON-LD specification is going to support the complexity 
necessary to support each concept. The entire section on Advanced Concepts 
should be considered as discussion points; it is merely a list of 
possibilities where all of the benefits and drawbacks have not been explored.
</p>

<section>
<h2>Vocabulary Profiles</h2>

<p>One of the more powerful features of RDFa 1.1 Core is the ability to specify 
a collection of prefixes and terms that can be re-used by a processor to simplfy
markup. JSON-LD provides a similar mechanism called Vocabulary Profiles, which is 
the inclusion of a context external to the JSON-LD document.</p>

<p>The example below demonstrates how one may specify an external Vocabulary
Profile. Assume the following profile exists at this imaginary URL:
<code>http://example.org/profiles/contacts</code>.</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": 
  {
     "xsd": "http://www.w3.org/2001/XMLSchema#",
     "name": "http://xmlns.com/foaf/0.1/name",
     "age": "http://xmlns.com/foaf/0.1/age",
     "homepage": "http://xmlns.com/foaf/0.1/homepage",
     "#types":
     {
        "age": "xsd:integer",
        "homepage": "xsd:anyURI",
     }
  }
}
-->
</pre>

<p>The profile listed above can be used in the following way:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@profile": "http://example.org/profiles/contacts",
  "name": "John Smith",
  "age": "41",
  "homepage": "http://example.org/home/"
}
-->
</pre>

<p>The example above would generate the following triples:</p>

<pre class="example" data-transform="updateExample">
<!--
_:bnode1
   <http://xmlns.com/foaf/0.1/name>
      "John Smith" .
_:bnode1
   <http://xmlns.com/foaf/0.1/age>
      "41"^^http://www.w3.org/2001/XMLSchema#integer .
_:bnode1
   <http://xmlns.com/foaf/0.1/homepage>
      <http://example.org/home/> .
-->
</pre>

</section>

<section>
<h2>Disjoint Graphs</h2>

<p>When serializing an RDF graph that contains two or more sections of the
graph which are entirely disjoint, one must use an array to express the graph
as two graphs. This may not be acceptable to some authors, who would rather
express the information as one graph. Since, by definition, disjoint graphs
require there to be two top-level objects, JSON-LD utilizes a mechanism that
allows disjoint graphs to be expressed using a single graph.</p>

<p>Assume the following RDF graph:</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/people#john> 
   <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
      <http://xmlns.com/foaf/0.1/Person> .
<http://example.org/people#jane> 
   <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
      <http://xmlns.com/foaf/0.1/Person> .
-->
</pre>

<p>Since the two subjects are entirely disjoint with one another, it is
impossible to express the RDF graph above using a single JSON-LD associative
array.</p>

<p>In JSON-LD, one can use the subject to express disjoint graphs as a 
single graph:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@": 
  [
    {
      "@": "http://example.org/people#john",
      "a": "foaf:Person"
    },
    {
      "@": "http://example.org/people#jane",
      "a": "foaf:Person"
    }
  ]
}
-->
</pre>

<p>A disjoint graph could also be expressed like so:</p>

<pre class="example" data-transform="updateExample">
<!--
[
  {
    "@": "http://example.org/people#john",
    "a": "foaf:Person"
  },
  {
    "@": "http://example.org/people#jane",
    "a": "foaf:Person"
  }
]
-->
</pre>

</section>

<section>
<h2>The JSON-LD API</h2>

<p>This API provides a clean mechanism that enables developers to convert 
JSON-LD data into a format that is easier to work with in various programming
languages.
</p>

<dl title="[NoInterfaceObject] interface JSONLDProcessor" class="idl">

  <dt>object toProjection()</dt>
  <dd>Parses JSON-LD text into an RDF API Projection object as specified
    by the RDF API specification [[!RDF-API]].
    If there are any errors, <code>null</code> is returned.
  <dl class="parameters">
     <dt>DOMString jsonld</dt>
     <dd>The JSON-LD string to parse into the Projection.</dd>
     <dt>object? template</dt>
     <dd>The Projection template to use when building the Projection.</dd>
     <dt>DOMString? subject</dt>
     <dd>The subject to use when building the Projection.</dd>
     <dt>JSONLDParserCallback optional? callback</dt>
     <dd>A callback that is called whenever a processing error occurs on
     the given JSON-LD string.</dd>
  </dl>
  </dd>

  <dt>Graph toGraph()</dt>
  <dd>Parses JSON-LD and transforms the data into an Graph, which is 
  compatible with the RDF Interfaces API specification [[!RDF-INTERFACES]]. 
  This method will 
  return <code>null</code> if there are any errors, or if the RDF Interfaces 
  API is not available for use.
  <dl class="parameters">
     <dt>DOMString jsonld</dt>
     <dd>The JSON-LD string to parse into the RDFGraph.</dd>
     <dt>JSONLDParserCallback optional? callback</dt>
     <dd>A callback that is called whenever a processing error occurs on
     the given JSON-LD string.</dd>
  </dl>
  </dd>

</dl>

<p>The JSONLDParserCallback is called whenever a processing error occurs on
input data.</p>

<dl title="[NoInterfaceObject Callback] interface JSONLDProcessorCallback" 
    class="idl">

  <dt>void error()</dt>
  <dd>This callback is invoked whenever an error occurs during processing.
  <dl class="parameters">
     <dt>DOMString error</dt>
     <dd>A descriptive error string returned by the processor.</dd>
  </dl>
  </dd>
</dl>

<p>The following example demonstrates how to convert JSON-LD to a projection
that is directly usable in a programming environment:
</p>

<pre class="example" data-transform="updateExample">
<!--
// retrieve JSON-LD from a Web Service
var jsonldString = fetchPerson();

// This map, usually defined once per script, defines how to map incoming 
// JSON-LD to JavaScript objects
var myTemplate = { "http://xmlns.com/foaf/0.1/name" : "name",
                   "http://xmlns.com/foaf/0.1/age" : "age",
                  "http://xmlns.com/foaf/0.1/homepage" : "homepage" };

// Map the JSON-LD to a language-native object
var person = jsonld.toProjection(jsonldString, myTemplate);

// Use the language-native object
alert(person.name + " is " + person.age + " years old. " +
      "Their homepage is: " + person.homepage);
-->
</pre>

<p>A JSON-LD Serializer is also available to map a language-native object
to JSON-LD.

<dl title="[NoInterfaceObject] interface JSONLDSerializer" class="idl">

  <dt>DOMString normalize()</dt>
  <dd>Serializes a language-native object into a normalized JSON-LD string.
  Normalization is important when performing things like equality comparison
  and digital signature creation and verification.
  <dl class="parameters">
     <dt>object obj</dt>
     <dd>An associative array of key-value pairs that should be converted
     to a JSON-LD string. It is assumed that a map already exists for the
     data.</dd>
  </dl>
  </dd>
</dl>

<h3>The Normalization Algorithm</h3>

<p class="issue">This algorithm is very rough, untested, and probably contains
many bugs. Use at your own risk. It will change in the coming months.</p>

<p>The JSON-LD normalization algorithm is as follows:</p>

<ol class="algorithm">
  <li>Remove the <code>@context</code> key and preserve it as the 
  <tdef>transformation map</tdef> while running this algorithm.</li>
  <li>For each key
   <ol class="algorithm">
    <li>If the key is a CURIE, expand the CURIE to an IRI using the
        <tref>transformation map</tref>.</li>
   </ol>
  </li>
  <li>For each value
   <ol class="algorithm">
    <li>If the value should be type coerced per the 
        <tref>transformation map</tref>, ensure that it is transformed to the
        new value.</li>
    <li>If the value is a CURIE, expand the CURIE to an IRI using the
        <tref>transformation map</tref>.</li>
    <li>If the value is a <tref>typed literal</tref> and the type is a CURIE,
        expand it to an IRI using the <tref>transformation map</tref>.</li>
    <li>When generating the final value, use expanded object value form to
      store all IRIs, typed literals and <tref>plain literal</tref>s with language
      information.</li>
   </ol>
  </li>
  <li>Output each sorted key-value pair without any extraneous whitespace. If 
  the value is an associative array, perform this algorithm, starting
  at step #1, recursively on the sub-tree. There should be no nesting in
  the outputted JSON data. That is, the top-most element should be an
  array. Each item in the array contains a single subject with a 
  corresponding array of properties in UTF-8 sort order. Any related 
  objects that are complex objects themselves should be given a top-level 
  object in the top-level array.</li>
  </li>
</ol>

<p class="issue">Note that normalizing named blank nodes is impossible at
present since one would have to specify a blank node naming algorithm. For
the time being, you cannot normalize graphs that contain named blank
nodes. However, normalizing graphs that contain non-named blank nodes 
is supported.</p>

<pre class="example" data-transform="updateExample">
<!--
var myObj = { "@context" : { 
                "xsd" : "http://www.w3.org/2001/XMLSchema#",
                "name" : "http://xmlns.com/foaf/0.1/name",
                "age" : "http://xmlns.com/foaf/0.1/age",
                "homepage" : "http://xmlns.com/foaf/0.1/homepage",
                "@coerce": {
                   "xsd:nonNegativeInteger": "age",
                   "xsd:anyURI": "homepage"
                }
              },
              "name" : "Joe Jackson",
              "age" : "42",
              "homepage" : "http://example.org/people/joe" };

// Map the language-native object to JSON-LD
var jsonldText = jsonld.normalize(myObj);
-->
</pre>

<p>After the code in the example above has executed, the 
<strong>jsonldText</strong> value will be (line-breaks added for 
readability):</p>

<pre class="example" data-transform="updateExample">
<!--
[{"http://xmlns.com/foaf/0.1/age":{"@datatype":"http://www.w3.org/2001/XMLSchema#nonNegativeInteger","@literal":"42"},
"http://xmlns.com/foaf/0.1/homepage":{"@iri":"http://example.org/people/joe"},
"http://xmlns.com/foaf/0.1/name":"Joe Jackson"}]
-->
</pre>

<p>When normalizing <strong>xsd:double</strong> values, implementers MUST
ensure that the normalized value is a string. In order to generate the
string from a <strong>double</strong> value, output equivalent to the
<code>printf("%1.6e", value)</code> function in C MUST be used where
<strong>"%1.6e"</strong> is the string formatter and <strong>value</strong>
is the value to be converted.</p>

<p>To convert the a double value in JavaScript, implementers can use the 
following snippet of code:</p>

<pre class="example" data-transform="updateExample">
<!--
// the variable 'value' below is the JavaScript native double value that is to be converted
(value).toExponential(6).replace(/(e(?:\+|-))([0-9])$/, '$10$2')
-->
</pre>

<p class="note">When data needs to be normalized, JSON-LD authors should
not use values that are going to undergo automatic conversion. This is due
to the lossy nature of <strong>xsd:double</strong> values.</p>

<p class="issue">Round-tripping data can be problematic if we mix and
match @coerce rules with JSON-native datatypes, like integers. Consider the 
following code example:</p>

<pre class="example" data-transform="updateExample">
<!--
var myObj = { "@context" : { 
                "number" : "http://example.com/vocab#number",
                "@coerce": {
                   "xsd:nonNegativeInteger": "number"
                }
              },
              "number" : 42 };

// Map the language-native object to JSON-LD
var jsonldText = jsonld.normalize(myObj);

// Convert the normalized object back to a JavaScript object
var myObj2 = jsonld.parse(jsonldText);
-->
</pre>

<p class="issue">At this point, myObj2 and myObj will have different
values for the "number" value. myObj will be the number 42, while
myObj2 will be the string "42". This type of data round-tripping
error can bite developers. We are currently wondering if having a
"coerce validation" phase in the parsing/normalization phases would be a 
good idea. It would prevent data round-tripping issues like the
one mentioned above.</p>

</section>

</section>

</section>

<section class="appendix">
<h1>The Default Context</h1>

<p>The <tdef>default context</tdef> is provided to ensure that there are a
reasonable set of prefixes and terms available to all JSON-LD developers.
Mappings specified by the <tref>default context</tref> SHOULD NOT be overwritten by
JSON-LD authors. All JSON-LD processors MUST load the following context 
in as the intial context before processing JSON-LD text.</p>

<pre>
{
  "@context":
  {
    "@vocab": "",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "owl": "http://www.w3.org/2002/07/owl#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dcterms": "http://purl.org/dc/terms/",
    "foaf": "http://xmlns.com/foaf/0.1/",
    "cal": "http://www.w3.org/2002/12/cal/ical#",
    "vcard": "http://www.w3.org/2006/vcard/ns# ",
    "geo": "http://www.w3.org/2003/01/geo/wgs84_pos#",
    "cc": "http://creativecommons.org/ns#",
    "sioc": "http://rdfs.org/sioc/ns#",
    "doap": "http://usefulinc.com/ns/doap#",
    "com": "http://purl.org/commerce#",
    "ps": "http://purl.org/payswarm#",
    "gr": "http://purl.org/goodrelations/v1#",
    "sig": "http://purl.org/signature#",
    "ccard": "http://purl.org/commerce/creditcard#"
    "@coerce": 
    {
      "xsd:anyURI": ["rdf:type", "rdf:rest", "foaf:homepage", "foaf:member"],
      "xsd:integer": "foaf:age"
    }
  }
}
</pre>
</section>

<section class="appendix">
<h1>Acknowledgements</h1>

<p>The editor would like to thank Mark Birbeck, who provided a great deal of the
rationale and reasoning behind the JSON-LD work via his work on RDFj, 
Dave Longley who reviewed, provided feedback, and performed several
implementation on the specification, and Ian Davis, who created RDF/JSON. 
Thanks also to Nathan Rixham, Bradley P. Allen and Richard Cyganiak for their 
input on the specification.</p>
</section>

</body>
</html>

