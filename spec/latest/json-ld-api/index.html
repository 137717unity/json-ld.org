<!DOCTYPE html>
<html>
<head>
<title>The JSON-LD API 1.0</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<!--
  === NOTA BENE ===
  For the three scripts below, if your spec resides on dev.w3 you can check them
  out in the same tree and use relative links so that they'll work offline,
  -->
<script type="text/javascript"
  src="http://www.w3.org/Tools/respec/respec-w3c-common" class="remove">
 </script>
<script type="text/javascript" class="remove">
//<![CDATA[
    var preProc = {
          apply:  function(c) {
                    // extend the bibliography entries
                    berjon.biblio["MICRODATA"] = "<cite><a href=\"http://www.w3.org/TR/2012/WD-microdata-20120329/\">HTML Microdata</a></cite> Ian Hickson Editor. World Wide Web Consortium (work in progress). 29 March 2012. This edition of the HTML Microdata specification is http://www.w3.org/TR/2012/WD-microdata-20120329/. The <a href=\"http://www.w3.org/TR/microdata/\">latest edition of HTML Microdata</a> is available at http://www.w3.org/TR/microdata/";
                    berjon.biblio["JSON-LD"] = "<cite><a href=\"http://json-ld.org/spec/ED/json-ld-syntax/20120522/\">The JSON-LD Syntax</a></cite> Manu Sporny, Gregg Kellogg, Markus Lanthaler Editors. World Wide Web Consortium (work in progress). 22 May 2012. Editor's Draft. This edition of the JSON-LD Syntax specification is http://json-ld.org/spec/ED/json-ld-syntax/20120522/. The <a href=\"http://json-ld.org/spec/latest/json-ld-syntax/\">latest edition of the JSON-LD Syntax</a> is available at http://json-ld.org/spec/latest/json-ld-syntax/";
                    berjon.biblio["JSON-POINTER"] = "<cite><a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-02\">JSON Pointer</a></cite> P. Bryan, Ed. IETF Draft. URL: <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-02\">http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-02</a>";
                    berjon.biblio["RDF-NORMALIZATION"] = "<cite><a href=\"http://json-ld.org/spec/ED/rdf-graph-normalization/20111016/\">RDF Graph Normalization</a></cite> Manu Sporny, Dave Longley Editors. World Wide Web Consortium (work in progress). 16 October 2011. Editor's Draft. This edition of the RDF Graph Normalization specification is http://json-ld.org/spec/ED/rdf-graph-normalization/20111016/. The <a href=\"http://json-ld.org/spec/latest/rdf-graph-normalization/\">latest edition of RDF Graph Normalization</a> is available at http://json-ld.org/spec/latest/rdf-graph-normalization/";
                    berjon.biblio["IEEE-754-1985"] = "IEEE. <cite>IEEE Standard for Binary Floating-Point Arithmetic.</cite> See <a href=\"http://standards.ieee.org/reading/ieee/std_public/description/busarch/754-1985_desc.html\">http://standards.ieee.org/reading/ieee/std_public/description/busarch/754-1985_desc.html</a>";
                    berjon.biblio["RDF-CONCEPTS"] = "<cite><a href=\"http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/\">RDF 1.1 Concepts and Abstract Syntax</a></cite> Richard Cyganiak, David Wood, Editors. World Wide Web Consortium (work in progress). 30 May 2012. Editor's Draft. This edition of the JSON-LD Syntax specification is http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/. The <a href=\"http://www.w3.org/TR/rdf11-concepts/\">latest edition of the JSON-LD Syntax</a> is available at http://www.w3.org/TR/rdf11-concepts/";
                    berjon.biblio["WEBIDL"] = "<cite><a href=\"http://www.w3.org/TR/2012/CR-WebIDL-20120419/\">Web IDL</a></cite> Cameron McCormack, Editor. World Wide Web Consortium. 19 April 2012. Candidate Recommendataion. This edition of Web IDL is http://www.w3.org/TR/2012/CR-WebIDL-20120419/. The <a href=\"http://dev.w3.org/2006/webapi/WebIDL/\">latest edition of Web IDL</a> is available at http://dev.w3.org/2006/webapi/WebIDL/";

                    // process the document before anything else is done
                    var refs = document.querySelectorAll('adef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'dfn' ) ;
                        var tit = item.getAttribute('title') ;
                        if (!tit) {
                            tit = con;
                        }
                        sp.className = 'adef' ;
                        sp.title=tit ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    refs = document.querySelectorAll('aref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'aref' ;
                        sp.setAttribute('title', con);
                        sp.innerHTML = '@'+con ;
                        p.replaceChild(sp, item) ;
                    }
                    // local datatype references
                    refs = document.querySelectorAll('ldtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'datatype idlType';
                        sp.title = ref ;
                        sp.setAttribute('href', '#idl-def-' + ref);
                        sp.innerHTML = '<code>' + con + '</code>';
                        p.replaceChild(sp, item) ;
                    }
                    // external datatype references
                    refs = document.querySelectorAll('dtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'externalDFN';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now do terms
                    refs = document.querySelectorAll('tdef') ;
                    var tdefs = [];
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_').toLowerCase() ;
                        }

                        if ( tdefs[ref]) {
                          throw "Duplicate definition of term '" + ref + "'" ;
                        }

                        var sp = document.createElement( 'dfn' ) ;
                        tdefs[ref] = sp ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now term references
                    refs = document.querySelectorAll('tref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_').toLowerCase() ;
                        }

                        if ( !tdefs[ref]) {
                          throw "Reference to undefined term '" + ref + "'" ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        var id = item.textContent ;
                        sp.className = 'tref' ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                }
        } ;


      var respecConfig = {
          doRDFa: "1.1",
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          //publishDate:          "2010-04-29",
          copyrightStart:       "2010",

          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "json-ld-api",
          subtitle:             "An Application Programming Interface for the JSON-LD Syntax",
          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2012-05-24",
          previousMaturity:     "ED",
          previousDiffURI:      "http://json-ld.org/spec/ED/json-ld-api/20120524/",
          diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://json-ld.org/spec/latest/json-ld-api/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS: [
              "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
              "spec.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Manu Sporny", url: "http://manu.sporny.org/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
              { name: "Dave Longley", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
              { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
                company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
          ],

          // authors, add as many as you like.
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          authors:  [
              { name: "Dave Longley", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
              { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
                company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
          ],

          // name of the WG
          wg:           "Linking Data in JSON Community Group",

          // URI of the public WG page
          wgURI:        "http://json-ld.org/",

          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-linked-json@w3c.org",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          maxTocLevel: 4,
          preProcess: [ preProc ],
          alternateFormats: [ {uri: "diff-20120524.html", label: "diff to previous version"} ],
      };

      function _esc(s) {
          s = s.replace(/&/g,'&amp;');
          s = s.replace(/>/g,'&gt;');
          s = s.replace(/"/g,'&quot;');
          s = s.replace(/</g,'&lt;');
          return s;
      }

      function updateExample(doc, content) {
        // perform transformations to make it render and prettier
        content = content.replace(/<!--/, '');
        content = content.replace(/-->/, '');
        content = _esc(content);
        content = content.replace(/\*\*\*\*([^*]*)\*\*\*\*/g, '<span class="diff">$1</span>') ;
        return content ;
      }
//]]>
  </script>
<style type="text/css">
.diff { font-weight:bold; color:#0a3; }
ol.algorithm.update { margin-left: 2em; }
ol.algorithm.update>li { list-style-type: none; }
ol.algorithm.update>li>span.list-number {
  display:block;
  float: left;
  margin-left: -3.5em;
}
</style>
</head>

<body>
<section id="abstract">
<p>
JSON [[!RFC4627]] has proven to be a highly useful object serialization and
messaging format. JSON-LD [[!JSON-LD]] harmonizes the representation of
Linked Data in JSON by outlining a common JSON representation format for
expressing directed graphs; mixing both Linked Data and non-Linked Data in
a single document. This document outlines an Application Programming
Interface and a set of algorithms for programmatically transforming
JSON-LD documents.
</p>
</section>

<section id='sotd'>
<p>This document is an experimental work in progress.</p>
<!-- <p>
This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from another
document. W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This
enhances the functionality and interoperability of the Web.
</p> -->
</section>

<section>
<h1>Introduction</h1>

<p>
JSON, as specified in [[!RFC4627]], is a simple language for representing
data on the Web. Linked Data is a technique for creating a graph of interlinked data across
different
documents or Web sites. Data entities are described using <tref>IRI</tref>s,
which are typically dereferencable and thus may be used to find more
information about an entity, creating a "Web of Knowledge". JSON-LD is intended to be a simple
publishing method for expressing not only Linked Data in JSON, but also for adding
semantics to existing JSON.
</p>

<p>
JSON-LD is designed as a light-weight syntax that can be used to express
Linked Data. It is primarily intended to be a way to use Linked Data
in Javascript and other Web-based programming environments. It is also
useful when building interoperable Web services and when storing Linked
Data in JSON-based document storage engines. It is practical and designed
to be as simple as possible, utilizing the large number of JSON parsers
and libraries available today. It is designed to be able to
express key-value pairs, RDF data, RDFa [[RDFA-CORE]] data, Microformats
[[MICROFORMATS]] data, and Microdata [[MICRODATA]]. That is, it supports
every major Web-based structured data model in use today.
</p>

<p>
The syntax does not necessarily require applications to change their JSON, but
allows to easily add meaning by adding context in a way that is either in-band or
out-of-band. The syntax is designed to not disturb already deployed systems
running on JSON, but provide a smooth upgrade path from JSON to JSON with
added semantics. Finally, the format is intended to be easy to parse, efficient to
generate, convertible to RDF in one pass, and require a very small memory footprint
in order to operate.
</p>

<section>
<h2>How to Read this Document</h2>

<p>
This document is a detailed specification for a serialization of Linked
Data in JSON. The document is primarily intended for the following audiences:
</p>

<ul>
  <li>Authors that want a very detailed view of how JSON-LD processors
  operate.</li>
  <li>Software developers that want to implement processors and APIs for
  JSON-LD.</li>
</ul>

<p>
To understand the basics in this specification you must first be familiar with
JSON, which is detailed in [[!RFC4627]]. You must also understand the
JSON-LD Syntax [[!JSON-LD]], which is the base syntax used by all of the
algorithms in this document. To understand the API and how it is
intended to operate  in a programming environment, it is useful to have working
knowledge of the JavaScript programming language [[ECMA-262]] and
WebIDL [[!WEBIDL]]. To understand how JSON-LD maps to RDF, it is helpful to be
familiar with the basic RDF concepts [[!RDF-CONCEPTS]].</p>

<p>
  Examples may contain references to existing vocabularies and use <tref>prefix</tref>es to refer to vocabularies. The following is a list of all vocabularies and their <tref>prefix</tref> abbreviations, as used in this document:
</p>
<ul>
  <li>The <a href="http://purl.org/dc/terms/">Dublin Core</a>
  vocabulary (abbreviation: <code>dc</code>, e.g., <code>dc:title</code>)</li>
  <li>The <a href="http://xmlns.com/foaf/0.1/">Friend of a Friend</a>
  vocabulary (abbreviation: <code>foaf</code>, e.g., <code>foaf:knows</code>)</li>
  <li>The <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#">RDF</a>
  vocabulary (abbreviation: <code>rdf</code>, e.g., <code>rdf:type</code>)</li>
  <li>The <a href="http://www.w3.org/2001/XMLSchema#">XSD</a>
  vocabulary (abbreviation: <code>xsd</code>, e.g., <code>xsd:integer</code>)</li>
</ul>

<p>
  JSON [[RFC4627]] defines several terms which are used throughout this document:
  <dl>
    <dt><tdef>JSON object</tdef></dt><dd>
      An object structure is represented as a pair of curly brackets surrounding zero or
      more name/value pairs. A name is a <tref>string</tref>. A single colon comes after
      each name, separating the name from the value. A single comma separates a value
      from a following name. The names within an object SHOULD be unique.
    </dd>
    <dt><tdef>array</tdef></dt>
    <dd>
      An array is an ordered collection of values. An array structure is represented as square brackets surrounding zero or more values (or elements). Elements are separated by commas.  Within JSON-LD, array order is not preserved by default, unless
      specific markup is provided. This is because the basic data model of JSON-LD is a <tref>linked data graph</tref>, which is inherently unordered.
    </dd>
    <dt><tdef>string</tdef></dt><dd>
      A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. A
      character is represented as a single character string.
    </dd>
    <dt><tdef>number</tdef></dt>
    <dd>
      A number is is similar to that used in most programming languages, except that the octal and hexadecimal formats are not used and that leading zeros are not allowed.</dd>
    <dt><tdef>true</tdef> and <tdef>false</tdef></dt><dd>
      Boolean values.
    </dd>
    <dt><tdef>null</tdef></dt><dd>
      The use of the <tref>null</tref> value within JSON-LD is used to ignore or reset values.
    </dd>
    <dt><tdef>subject definition</tdef></dt><dd>
      A <tref>JSON object</tref> used to represent a <tref>subject</tref> and one or more properties
      of that subject. A <tref>JSON object</tref> is a subject definition if it does not contain the keys
      <code>@value</code>, <code>@list</code> or <code>@set</code> and it has one or more keys other than <code>@id</code>.</dd>
    <dt><tdef>subject reference</tdef></dt><dd>
      A <tref>JSON object</tref> used to reference a subject having only the <code>@id</code> key.</dd>
  </dl>
</p>
</section>

<section>
<h2>Linked Data</h2>
<p>
The following definition for <tref>Linked Data</tref> is the one that will
be used for this specification.
</p>
<ol>
  <li><tdef>Linked Data</tdef> is a set of documents, each containing a representation of a <tref>linked data graph</tref>.</li>
  <li>A <tdef>linked data graph</tdef> is an unordered labeled directed graph, where <tref title="node">nodes</tref> are <tref>subject</tref>s or <tref>object</tref>s, and edges are properties.
    A linked data graph may be named using a <tdef>graph name</tdef>.
    A <tref>linked data graph</tref> is a generalized representation of a
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graph</a></cite>
    as defined in [[!RDF-CONCEPTS]].</li>
  <li>A <tdef>node</tdef> may be an <tref>IRI</tref>, <tref>blank node</tref>, or <tref>literal</tref>.</li>
  <li>An <tdef><abbr title="Internationalized Resource Identifier">IRI</abbr></tdef> (an Internationalized Resource Identifier) is described in [[!RFC3987]])
    and the use with JSON-LD conforms to the definition of
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri">IRI</a></cite> in [[!RDF-CONCEPTS]].</li>
  <li>A <tdef>dataset</tdef> represents a collection of
    <tref title="linked data graph">linked data graphs</tref>. It is comprized of
    a <tdef>default graph</tdef>, which does not have a name,
    and zero or more <tdef title="named graph">named graphs</tdef> each named using
    a <tref>node</tref> See
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#section-multigraph">Abstract Syntax for Working with Multiple Graphs</a></cite>
    in [[!RDF-CONCEPTS]].</li>
  <li>A <tdef>subject</tdef> is any <tref>node</tref> in a <tref>linked data graph</tref> with at least one outgoing edge.</li>
  <li>An <tdef>object</tdef> is a <tref>node</tref> in a <tref>linked data graph</tref> with at least one incoming edge.</li>
  <li>An object MAY be a <tref>subject</tref> and <tref>object</tref> at the same time.</li>
  <li>A <tdef>property</tdef> is an edge of the <tref>linked data graph</tref>.
    Also known as a <tdef>predicate</tdef> in [[!RDF-CONCEPTS]].</li>
  <li>A <tref>property</tref> SHOULD be an <tref>IRI</tref>. To be converted
    to or from RDF, a <tref>property</tref> MUST be an <tref>IRI</tref></li>
  <li>A <tdef>blank node</tdef> is a <tref>node</tref> which is neither an <tref>IRI</tref> nor a <tref>literal</tref>
    but representes an unknown <tref>node</tref>, which may be either an <tref>IRI</tref> or a <tref>literal</tref>.
    Within a document, a <tref>blank node</tref> may have an identifier used for intra-document reference
    purposes only. See [[!RDF-CONCEPTS]] for a further description of
  <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node">blank nodes</a></cite>.</li>
  <li>An <tref>IRI</tref> <tref>node</tref> in a <tref>linked data graph</tref> SHOULD be identify a <tref>Linked Data</tref> <em>resource</em> describing the <tref>subject</tref>, <tref>object</tref> or <tref>property</tref>.</li>
  <li>A <tdef>literal</tdef> is used to identify values such as numbers and dates.
    A <tref>literal</tref> may be an <tref>object</tref> in a <tref>linked data graph</tref>.
    See [[!RDF-CONCEPTS]] for a further definition of
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">literal</a></cite>.</li>
  <li>A <tdef>Quad</tdef> contains a <tref>subject</tref>, <tref>predicate</tref>, <tref>object</tref>,
    and optionally a <tref>graph name</tref>.
    See [[!RDF-CONCEPTS]] definition for
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">RDF triple</a></cite>,
    which most closely aligns to <a>Quad</a>.</li>
</ol>
</section>

<section>
  <h2>Contributing</h2>

  <p>There are a number of ways that one may participate in the development of
    this specification:</p>

  <ul>
    <li>Technical discussion typically occurs on the public mailing list:
      <a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

    <li><a href="http://json-ld.org/minutes/">Public teleconferences</a> are held
      on Tuesdays at 1500UTC on the second and fourth week of each month.</li>

    <li>Specification bugs and issues should be reported in the
      <a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>.</li>

    <li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a> for the
      specification can be found on Github.</li>

    <li>The <a href="http://webchat.freenode.net/?channels=json-ld">#json-ld</a>
      IRC channel is available for real-time discussion on irc.freenode.net.</li>
  </ul>

</section>

</section>

<section>
  <h2>The Application Programming Interface</h2>

  <p>This API provides a clean mechanism that enables developers to convert
  JSON-LD data into a a variety of output formats that are easier to work with in
  various programming languages. If a JSON-LD API is provided in a programming
  environment, the entirety of the following API MUST be implemented.
  </p>

  <section>
    <h3>JsonLdProcessor</h3>
    <dl title="[NoInterfaceObject] interface JsonLdProcessor" class="idl">

      <dt>void expand()</dt>
      <dd>
        <a href="#expansion">Expands</a> the given <code>input</code> according to
        the steps in the <a href="#expansion-algorithm">Expansion Algorithm</a>. The
        <code>input</code> MUST be copied, expanded and returned if there are
        no errors. If the expansion fails, an appropriate exception MUST be thrown.

        <dl class="parameters">
          <dt>object or object[] or URL input</dt>
          <dd>The JSON-LD object or array of JSON-LD objects to perform the expansion upon or an
            <tref>IRI</tref> referencing the JSON-LD document to expand.</dd>
          <dt>ObjectOrURL? context</dt>
          <dd>An optional external context to use additionally to the context embedded in
            <code>input</code> when expanding the <code>input</code>.</dd>
          <dt>JsonLdCallback callback</dt>
          <dd>A callback that is called when processing is complete on
            the given <code>input</code>.</dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options that MAY affect the expansion algorithm such as, e.g., the
            input document's base <tref>IRI</tref>.</dd>
        </dl>

        <dl class="exception" title="InvalidContext">
          <dt>INVALID_SYNTAX</dt>
          <dd>A general syntax error was detected in the <code>@context</code>.
            For example, if a <code>@type</code> key maps to anything other than
            <code>@id</code> or an <tref>absolute IRI</tref>, this exception would be raised.</dd>
          <dt>LOAD_ERROR</dt>
          <dd>There was a problem encountered loading a remote context.</dd>
        </dl>

        <dl class="exception" title="ProcessingError">
          <dt>LIST_OF_LISTS_DETECTED</dt>
          <dd>A list of lists was detected. This is not supported in this
            version of JSON-LD.</dd>
        </dl>
      </dd>

      <dt>void compact()</dt>
      <dd>
        <a href="#compaction">Compacts</a> the given <code>input</code> using the
        <code>context</code> according to the steps in the
        <a href="#compaction-algorithm">Compaction Algorithm</a>. The
        <code>input</code> MUST be copied, compacted and returned if there are
        no errors. If the compaction fails, an appropirate exception MUST be
        thrown.

        <dl class="parameters">
          <dt>object or object[] or URL input</dt>
           <dd>The JSON-LD object or array of JSON-LD objects to perform the compaction upon or an
            <tref>IRI</tref> referencing the JSON-LD document to compact.</dd>
          <dt>object or URL context</dt>
          <dd>The context to use when compacting the <code>input</code>; either in the
            form of an <tref>JSON object</tref> or as <tref>IRI</tref>.</dd>
          <dt>JsonLdCallback callback</dt>
          <dd>A callback that is called when processing is complete on
            the given <code>input</code>.</dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options that MAY affect the expansion algorithm such as, e.g., the
            input document's base <tref>IRI</tref>. This also includes <code>optimize</code>,
            which if set will cause processor-specific optimization.</dd>
        </dl>

        <dl class="exception" title="InvalidContext">
          <dt>INVALID_SYNTAX</dt>
          <dd>A general syntax error was detected in the <code>@context</code>.
            For example, if a <code>@type</code> key maps to anything other than
            <code>@id</code> or an <tref>absolute IRI</tref>, this exception would be raised.</dd>
          <dt>LOAD_ERROR</dt>
          <dd>There was a problem encountered loading a remote context.</dd>
        </dl>

        <dl class="exception" title="ProcessingError">
          <dt>LOSSY_COMPACTION</dt>
          <dd>The compaction would lead to a loss of information, such as a
            <code>@language</code> value.</dd>
          <dt>CONFLICTING_DATATYPES</dt>
          <dd>The target datatype specified in the coercion rule and the
            datatype for the typed literal do not match.</dd>
          <dt>LIST_OF_LISTS_DETECTED</dt>
          <dd>A list of lists was detected. This is not supported in this
            version of JSON-LD.</dd>
        </dl>
      </dd>

      <dt>void fromRDF()</dt>
      <dd>Creates a JSON-LD document given an set of <ldtref title="quad">Quads</ldtref>.
        <dl class="parameters">
          <dt>Quad[] input</dt>
          <dd>A <tref>dataset</tref> represented as an array of <ldtref title="quad">Quads</ldtref>.</dd>
          <dt>JsonLdCallback callback</dt>
          <dd>A callback that is called when processing is complete on
            the given <code>input</code>.</dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options that will affect the algorithm. This includes <code>notType</code>,
            which if set to <tref>true</tref> causes the resulting document to use <code>rdf:type</code>
            as a property, instead of <code>@type</code>.</dd>
        </dl>
      </dd>

      <dt>void toRDF()</dt>
      <dd>
        Processes the <code>input</code> according to the
        <a href="#convert-to-rdf-algorithm">Convert to RDF Algorithm</a>, calling
        the provided <code>callback</code> for each <ldtref>Quad</ldtref> generated.
        <dl class="parameters">
          <dt>object or object[] or URL input</dt>
          <dd>The JSON-LD object or array of JSON-LD objects to convert to RDF or a <a>URL</a>
            referencing the JSON-LD document to convert to RDF.</dd>
          <dt>QuadCallback callback</dt>
          <dd>A callback that is called when a <ldtref>Quad</ldtref> is created from processing
            the given <code>input</code>.
          </dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options that MAY affect the conversion to RDF such as, e.g.,
            the input document's base <tref>IRI</tref>.</dd>
        </dl>

        <dl class="exception" title="InvalidContext">
          <dt>INVALID_SYNTAX</dt>
          <dd>A general syntax error was detected in the <code>@context</code>.
            For example, if a <code>@type</code> key maps to anything other than
            <code>@id</code> or an <tref>absolute IRI</tref>, this exception would be raised.</dd>
          <dt>LOAD_ERROR</dt>
          <dd>There was a problem encountered loading a remote context.</dd>
        </dl>

        <dl class="exception" title="ProcessingError">
          <dt>LIST_OF_LISTS_DETECTED</dt>
          <dd>A list of lists was detected. This is not supported in this
            version of JSON-LD.</dd>
        </dl>

      </dd>

    </dl>

  </section>

  <section>
    <h3>Callbacks</h3>
  <section>
    <h3>JsonLdCallback</h3>
    <p>The <a>JsonLdCallback</a> is used to return a processed JSON-LD representation
      as the result of processing an API method.</p>

    <dl title="[NoInterfaceObject Callback] interface JsonLdCallback"
        class="idl">

      <dt>void jsonLd()</dt>
      <dd>This callback is invoked when processing is complete.
      <dl class="parameters">
         <dt>ObjectOrObjectArray jsonld</dt>
         <dd>The processed JSON-LD document.</dd>
      </dl>
      </dd>
    </dl>
  </section>
  <section>
    <h3>QuadCallback</h3>
    <p>The <a>QuadCallback</a> is called whenever the processor generates a
    quad during the <code>quad()</code> call.</p>

    <dl title="[NoInterfaceObject Callback] interface QuadCallback"
        class="idl">

      <dt>void quad()</dt>
      <dd>This callback is invoked whenever a quad is generated by the processor.
      <dl class="parameters">
         <dt>Quad quad</dt>
         <dd>The quad.</dd>
      </dl>
      </dd>
    </dl>
  </section>
  </section>

  <section>
    <h3>Data Structures</h3>
    <p>This section describes datatype definitions used within the JSON-LD API.</p>

    <section>
    <h3>URL</h3>
    <p>The <a>URL</a> datatype is a string representation of an <tref>IRI</tref>.</p>
    <div title="typedef DOMString URL" class="idl">
      This datatype indicates that the <tref>IRI</tref> is interpreted as a Universal Resource
      Locator
      identifying a document, which when parsed as JSON yields either a <code>JSON object</code>
      or <code>array</code>.
    </div>
    </section>

    <section>
    <h3>JsonLdOptions</h3>
    <p>The <a>JsonLdOptions</a> type is used to convery a set of options to an interface method.</p>
    <dl title="typedef object JsonLdOptions" class="idl">
      <dt><a>URL</a> base</dt>
      <dd>The Base IRI to use when expanding the document. This overrides the value of
        <em>input</em> if it is a <a>URL</a> or if it is a <code>object</code> or <code>object[]</code>.</dd>
      <dt>boolean optimize</dt>
      <dd>If set to <code>true</code>, the JSON-LD processor is allowed to
        optimize the output of the <a href="#compaction-algorithm">Compaction Algorithm</a>
        to produce even compacter representations. The algorithm for compaction
        optimization is beyond the scope of this specification and thus
        not defined. Consequently, different implementations MAY implement
        different optimization algorithms.</dd>
      <dt>boolean noType</dt>
      <dd>If set to <code>true</code>, the JSON-LD processor will not use the
        <code>@type</code> property when generating the output, and will use the
        expanded <code>rdf:type</code> IRI as the property instead of <code>@type</code>.</dd>
    </dl>
    </section>

    <p>The following data structures are used for representing data about
      RDF quads. They are used for normalization, <a>fromRDF</a>,
      and from <a>toRDF</a> interfaces.
    </p>

    <section>
    <h3>Quad</h3>
    <p>The <a>Quad</a> interface represents an RDF Quad.
      See [[!RDF-CONCEPTS]] definition for
      <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">RDF triple</a></cite>,
      which most closely aligns to <a>Quad</a>.
    </p>
    <dl title="[NoInterfaceObject] interface Quad" class="idl">
      <dt>readonly attribute Node subject</dt>
      <dd>The <tref>subject</tref> associated with the <a>Quad</a>.</dd>
      <dt>readonly attribute Node predicate</dt>
      <dd>The predicate associated with the <a>Quad</a>.
        Within JSON-LD, an <tdef>RDF predicate</tdef> is refered to as a
        <tref>property</tref></dd>
      <dt>readonly attribute Node object</dt>
      <dd>The <tref>object</tref> associated with the <a>Quad</a>.</dd>
      <dt>readonly attribute Node? graphName</dt>
      <dd>If present, the name associated with the <a>Quad</a> identifying
        it as a member of a <tref>named graph</tref>. If it is missing, the quad
        is a member of the <tref>default graph</tref>.
        <div class="issue">This element is at risk, and may be removed.</div>
      </dd>
    </dl>
    </section>

    <section>
    <h3>Node</h3>
    <p><ldtref>Node</ldtref> is the base class of <ldtref>IRI</ldtref>,
    <ldtref>BlankNode</ldtref>, and <ldtref>Literal</ldtref>. It is the IDL
    representation of a <tref>linked data graph</tref> <tref>node</tref>.</p>
    <dl title="[NoInterfaceObject] interface Node" class="idl">
    </dl>
    </section>

    <section>
    <h3>IRI</h3>
    <p>A <tref>node</tref> representing an <tref>IRI</tref>.</p>
    <dl title="[NoInterfaceObject] interface IRI : Node"
        class="idl">
        <dt>readonly attribute DOMString value</dt>
        <dd>The IRI identifier of the <tref>node</tref> as a [[UNICODE]] string.</dd>
    </dl>
    </section>

    <section>
    <h3>Blank Node</h3>

    <p>A <a>BlankNode</a> a representation of a <tref>blank node</tref>
      and is used to identify equivalent blank nodes within the same document.</p>

    <dl title="[NoInterfaceObject] interface BlankNode : Node" class="idl">
      <dt>readonly attribute DOMString identifier</dt>
      <dd>The temporary identifier of the <tref>blank node</tref>.
        The <code>identifier</code> MUST NOT be relied upon in any way between two
        separate processing runs of the same document or with a different document.</dd>
    </dl>

    <p class="note">Developers and authors must not assume that the
      value of a <tref>blank node</tref> will remain the same between two
      processing runs. <a>BlankNode</a> values are only valid for the
      most recent processing run on the document. <ldtref title="blanknode">BlankNodes</ldtref>
      values will often be generated differently by different processors.</p>

    <p class="note">Implementers MUST ensure that <a>BlankNode</a> values are unique
      within the current environment, two <ldtref 
      title="blanknode">BlankNodes</ldtref> are considered equal if, and only 
      if, their values are strictly equal.</p>
    </section>

    <section>
      <h3>Literal</h3>
      <p>Literals represent values such as numbers, dates and strings in
        RDF data. A <ldtref>Literal</ldtref> is comprised of three attributes:
      </p>

      <ul>
        <li>a lexical form of the <code>value</code></li>
        <li>an optional <code>language</code> tag</li>
        <li>a <code>datatype</code> specified by an <ldtref>IRI</ldtref></li>
      </ul>

      <p>Literals representing plain text in a natural language may have a
        <code>language</code> tag specified by a string token, as specified in
        [[!BCP47]], normalized to lowercase
        (e.g., <code>'en'</code>, <code>'fr'</code>, <code>'en-gb'</code>).
        They also have a datatype attribute such as <code>xsd:string</code>.
        If unspecified, the <code>datatype</code> defaults to <code>xsd:string</code>.
      </p>

      <p>Literals representing values with a specific datatype, such as
        the integer 72, may have a <code>datatype</code> attribute specified in the form
        of a <a>IRI</a> (e.g.,
        <code>xsd:integer</code>).</p>

      <p> See[[!RDF-CONCEPTS]] definition for
      <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">literal</a></cite>.</p>

      <dl title="[NoInterfaceObject] interface Literal : Node" class="idl">
        <dt>readonly attribute DOMString value</dt>
        <dd>The lexical form of the Literal's value.</dd>
        <dt>readonly attribute DOMString? language</dt>
        <dd>An optional language tag as defined in [[!BCP47]], normalized to lowercase.</dd>
        <dt>readonly attribute IRI? datatype</dt>
        <dd>An optional datatype identified by a IRI.</dd>
      </dl>
    </section>
  </section>

</section>

<section>
<h1>Algorithms</h1>

<p>All algorithms described in this section are intended to operate on
language-native data structures. That is, the serialization to a text-based
JSON document isn't required as input or output to any of these algorithms and
language-native data structures MUST be used where applicable.</p>

<section>
  <h2>Syntax Tokens and Keywords</h2>

  <p>JSON-LD specifies a number of syntax tokens and <tdef>keyword</tdef>s that are using
  in all algorithms described in this section:</p>

  <dl>
  <dt><code>@context</code></dt><dd>Used to set the <tref>local context</tref>.</dd>
  <dt><code>@id</code></dt><dd>Sets the active subject.</dd>
  <dt><code>@language</code></dt><dd>Used to specify the language for a literal.</dd>
  <dt><code>@type</code></dt><dd>Used to set the type of the active subject or the datatype of a literal.</dd>
  <dt><code>@value</code></dt><dd>Used to specify the value of a literal.</dd>
  <dt><code>@container</code></dt><dd>Used to set the container of a particular value.</dd>
  <dt><code>@list</code></dt><dd>Used to express an ordered set of data.</dd>
  <dt><code>@set</code></dt><dd>Used to express an unordered set of data.</dd>
  <dt><code>@graph</code></dt><dd>Used to explicitly express a <tref>linked data graph</tref>.</dd>
  <dt><code>:</code></dt><dd>The separator for JSON keys and values that use <tref title="compact_iri">compact IRIs</tref>.</dd>
  </dl>

  <p>All JSON-LD tokens and keywords are case-sensitive.</p>
</section>

<section>
  <h2>Algorithm Terms</h2>
  <dl>
    <dt><tdef>initial context</tdef></dt>
    <dd>
      a context that is specified to the algorithm before processing begins. The contents of the
      initial context is defined in <a href="#appendix-a">Appendix A</a>.
    </dd>
    <dt><tdef>active subject</tdef></dt>
    <dd>
      the currently active subject that the processor should use when
      processing.
    </dd>
    <dt><tdef>active property</tdef></dt>
    <dd>
      the currently active property that the processor should use when
      processing. The active property is represented in the original lexical form, which
      is used for finding coercion mappings in the <tref>active context</tref>.
    </dd>
    <dt><tdef>active object</tdef></dt>
    <dd>
      the currently active object that the processor should use when
      processing.
    </dd>
    <dt><tdef>active context</tdef></dt>
    <dd>
      a context that is used to resolve <tref>term</tref>s while the processing
      algorithm is running. The <tref>active context</tref> is the context
      contained within the <tref>processor state</tref>.
    </dd>
    <dt><tdef>compact IRI</tdef></dt>
    <dd>
      a compact IRI is has the form of <tref>prefix</tref> and <em>suffix</em> and is used as a way
      of expressing an IRI without needing to define separate <tref>term</tref> definitions for
      each IRI contained within a common vocabulary identified by <tref>prefix</tref>.
    </dd>
    <dt><tdef>local context</tdef></dt>
    <dd>
      a context that is specified within a <tref>JSON object</tref>,
      specified via the <code>@context</code> <tref>keyword</tref>.
    </dd>
    <dt><tdef>processor state</tdef></dt>
    <dd>
      the <tref>processor state</tref>, which includes the <tref>active
      context</tref>, <tref>active subject</tref>, and
      <tref>active property</tref>. The <tref>processor state</tref> is managed
      as a stack with elements from the previous <tref>processor state</tref>
      copied into a new <tref>processor state</tref> when entering a new
      <tref>JSON object</tref>.
    </dd>
    <dt><tdef>JSON-LD input</tdef></dt>
    <dd>
      The JSON-LD data structure that is provided as input to the algorithm.
    </dd>
    <dt><tdef>JSON-LD output</tdef></dt>
    <dd>
      The JSON-LD data structure that is produced as output by the algorithm.
    </dd>
    <dt><tdef>term</tdef></dt><dd>
      A <tref>term</tref> is a short word defined in a context that MAY be expanded to an <tref>IRI</tref>
    </dd>
    <dt><tdef>prefix</tdef></dt><dd>
      A <tref>prefix</tref> is a <tref>term</tref> that expands to a vocabulary base IRI. It
      is typically used along with a <em>suffix</em> to form a <tref>compact IRI</tref> to create an IRI
      within a vocabulary.
    </dd>
    <dt><tdef>language-tagged literal</tdef></dt><dd>
      A <tref>language-tagged literal</tref> is a <tref>literal</tref> without a datatype, including
      a language.
      See <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-literal">languaged-tagged literal</a></cite> in [[!RDF-CONCEPTS]].
    </dd>
    <dt><tdef>typed literal</tdef></dt><dd>
      A <tref>typed literal</tref> is a <tref>literal</tref> with an associated <tref>IRI</tref>
      which indicates the literal's datatype.
      See <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-typed-literal">languaged-tagged literal</a></cite> in [[!RDF-CONCEPTS]].
    </dd>
  </dl>
</section>

<section>
  <h2 id="context">Context Processing</h2>
  <p>Processing of JSON-LD data structure is managed recursively.
    During processing, each rule is applied using information provided by the <tref>active context</tref>.
    Processing begins by pushing a new <tref>processor state</tref> onto the <tref>processor state</tref> stack and
    initializing the <tref>active context</tref> with the <tref>initial context</tref>.
    If a <tref>local context</tref> is encountered,
    information from the <tref>local context</tref> is merged into the <tref>active context</tref>.</p>
  <p>The <tref>active context</tref> is used for expanding properties and values of a <tref>JSON object</tref> (or elements
    of an array) using a <tdef>term mapping</tdef>. It is also used to maintain
    <tdef>coercion mapping</tdef>s from terms to datatypes, <tdef>language mapping</tdef>s from terms to language codes,
    and <tdef>list mapping</tdef>s and <tdef>set mapping</tdef>s for terms. Processors MUST use the
    lexical form of the property when creating a mapping, as lookup is performed on lexical representations, not
    expanded IRI representations.</p>
  <p>A <tref>local context</tref> is identified within a <tref>JSON object</tref> having a <code>@context</code>
    property with a <tref>string</tref>, <tref>array</tref> or a <tref>JSON object</tref> value.
    When processing a <tref>local context</tref>, special processing rules apply:</p>
  <ol class="algorithm">
    <li>Create a new, empty <tref>local context</tref>.</li>
    <li>Let <em>context</em> be the value of <code>@context</code>
      <ol class="algorithm">
        <li id="process-context">If <em>context</em> equals <tref>null</tref>, reset the <tref>active context</tref>
          to the <tref>initial context</tref>.</li>
        <li>If <em>context</em> is an <tref>array</tref>, process each element as <em>context</em> in order
          by starting at <a href="#process-context">Step 2.1</a>.</li>
        <li>If <em>context</em> is a <tref>string</tref>, it MUST have a lexical form of <tref>absolute IRI</tref>.
          <ol class="algorithm">
            <li>Dereference <em>context</em>.</li>
            <li>If the resulting document is a JSON document, extract the top-level <code>@context</code>
              element using the JSON Pointer "/@context" as described in [[!JSON-POINTER]]. Set <em>context</em>
              to the extracted content and process it by starting at <a href="#process-context">Step 2.1</a>.</li>
          </ol>
        </li>
        <li>If <em>context</em> is a <tref>JSON object</tref>, perform the following steps:
          <ol class="algorithm">
            <li>If <em>context</em> has a <code>@language</code> property, it MUST have a value of a
              simple <tref>string</tref> or <tref>null</tref>. Add the language to the <tref>local context</tref>.</li>
            <li id="object-context">Otherwise, for each property in <em>context</em> perform the following steps:
              <ol class="algorithm">
                <li>If the property's value is a simple <tref>string</tref>, determine the IRI mapping value by
                  performing <a href="#iri-expansion">IRI Expansion</a> on the associated value. If the result of the IRI
                  mapping is an <tref>absolute IRI</tref>, merge the property into the <tref>local context</tref>
                  <tref>term mapping</tref>, unless the property is a JSON-LD <tref>keyword</tref>, in which
                  case throw an exception.</li>
                <li>Otherwise, if the property's value is <tref>null</tref> remove mapping, coercion,
                  container and language information associated with property from the
                  <tref>local context</tref>.</li>
                <li>Otherwise, the <em>property</em>'s <em>value</em> MUST be a <tref>JSON object</tref>.
                  <ol class="algorithm">
                    <li>If the <em>property</em> is a JSON-LD <tref>keyword</tref> and the value has
                      <code>@id</code>, <code>@language</code> or <code>@type</code> properties, throw an exception.
                      <div class="issue">Undecided if <code>@type</code> or <code>@graph</code> can take a
                        <code>@container</code> with <code>@set</code>.
                      </div>
                    </li>
                    <li>If the <em>property</em> has the form of <tref>term</tref>, its <em>value</em> MUST have an
                      <code>@id</code> property with a string value which MUST have the form of a <tref>term</tref>,
                      <tref>compact IRI</tref>, or <tref>absolute IRI</tref>. Determine the IRI mapping
                      by performing <a href="#iri-expansion">IRI Expansion</a> on the associated value.
                      If the result of the IRI mapping is an <tref>absolute IRI</tref>, merge the
                      <em>property</em> into the <tref>local context</tref> <tref>term mapping</tref>.</li>
                    <li>If the <em>property</em> has the form of of a <tref>compact IRI</tref> or <tref>absolute IRI</tref>,
                      the <em>value</em> MAY have a <code>@id</code> property with a string value which MUST have the
                      form of a <tref>term</tref>, <tref>compact IRI</tref>, or absolute <tref>IRI</tref>.
                      Determine the IRI mapping by performing <a href="#iri-expansion">IRI Expansion</a> on the associated
                      value. If the result of the IRI mapping is an <tref>absolute IRI</tref>, merge the
                      <em>property</em> into the <tref>local context</tref> <tref>term mapping</tref>.</li>
                    <li>If the <em>value</em> has a <code>@type</code> property, its value MUST have the form of a <tref>term</tref>,
                      <tref>compact IRI</tref>, <tref>absolute IRI</tref>, or the <tref>keyword</tref> <code>@id</code>.
                      Determine the IRI by performing <a href="#iri-expansion">IRI Expansion</a> on the associated value.
                      If the result of the IRI mapping is an <tref>absolute IRI</tref> or <code>@id</code>, merge into the
                      <tref>local context</tref> <tref>coercion mapping</tref> using the lexical value of the <em>property</em>.</li>
                    <li>If the <em>value</em> has a <code>@container</code> property, its value MUST be <code>@list</code> or
                      <code>@set</code>. Merge the <tref>list mapping</tref> or <tref>set mapping</tref> into the
                      <tref>local context</tref> using the lexical value of the <em>property</em>.</li>
                    <li>If the <em>value</em> has a <code>@language</code> property but no <code>@type</code> property, the value of the
                      <code>@language</code> property MUST be a <tref>string</tref> or <tref>null</tref>.
                      Merge the <tref>language mapping</tref> into the <tref>local context</tref> using the lexical value of the
                      <em>property</em>.</li>
                  </ol>
                </li>
                <li>Merge the <tref>local context</tref> into the <tref>active context</tref>.</li>
                <li>Repeat <a href="#object-context">Step 2.4.2</a> until no entries are added to the <tref>local
                  context</tref>.</li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <p class="note">It can be difficult to distinguish between a <tref>compact IRI</tref> and an <tref>absolute IRI</tref>,
    as a <tref>compact IRI</tref> may seem to be a valid IRI <em>scheme</em>. When performing repeated IRI expansion,
    a term used as a prefix may not have a valid mapping due to dependencies in resolving term definitions. By
    continuing <a href="#object-context">Step 2.3.2</a> until no changes are made, mappings to IRIs created
    using an undefined term prefix will eventually resolve to <tref>absolute IRI</tref>s.</p>

  <p class="issue"><a href="https://github.com/json-ld/json-ld.org/issues/43">Issue 43</a>
    concerns performing IRI expansion in the key position of a context definition.</p>
</section>

<section>
  <h2>IRI Expansion</h2>
  <p>Keys and some values are evaluated to produce an <tref>IRI</tref>. This section defines an algorithm for
    transforming a value representing an IRI into an actual IRI.</p>
  <p><tref>IRI</tref>s may be represented as an <tref>absolute IRI</tref>, a <tref>term</tref> or a <tref>compact IRI</tref>.</p>
  <p>An <tdef>absolute IRI</tdef> is defined in [[!RFC3987]] containing a <em>scheme</em> along with
    <em>path</em> and optional <em>query</em> and fragment segments. A <tdef>relative IRI</tdef> is an IRI
    that is relative some other <tref>absolute IRI</tref>; in the case of JSON-LD this is the base location
    of the document.</p>

  <p>The algorithm for generating an IRI is:
    <ol class="algorithm">
      <li>If the <tref>active context</tref> contains a <tref>term</tref> mapping for the value using
        a case-sensitive comparison, use the mapped value as an IRI.</li>
      <li>Otherwise, split the value into a <em>prefix</em> and <em>suffix</em> from the first occurrence of ':'.</li>
      <li>If the prefix is a '_' (underscore), the value represents a named <tref>blank node</tref>.</li>
      <li>If the <tref>active context</tref> contains a <tref>term</tref> mapping for <em>prefix</em> using
        a case-sensitive comparison, and <em>suffix</em> does not does not begin with '//'
        (i.e., it does not match a <em>hier-part</em> including
        <em>authority</em> (as defined in [[!RFC3986]]), generate an <tref>IRI</tref>
        by prepending the mapped prefix to the (possibly empty) suffix using textual concatenation. Note that an empty
        suffix and no suffix (meaning the value contains no ':' string at all) are treated equivalently.</li>
      <li>Otherwise, use the value directly as an IRI.</li>
    </ol>
  </p>
  <p class="note">
    Previous versions of this specification used <code>@base</code> and <code>@vocab</code> to define IRI prefixes
    used to resolve <tref title="relative IRI">relative IRIs</tref>. It was determined that this added too much complexity, but the issue
    can be re-examined in the future based on community input.
  </p>
</section>

<section>
  <h2>IRI Compaction</h2>
  <p>Some keys and values are expressed using <tref>IRI</tref>s. This section defines an
    algorithm for transforming an IRI (<em>iri</em>) to a <tref>term</tref> or <tref>compact IRI</tref> using the
    <tref>term</tref>s specified in the <tref>active context</tref> using an optional <em>value</em>.</p>

<section>
  <h3>IRI Compaction Algorithm</h3>
  <p>The algorithm for generating a <tref>compact IRI</tref> is:
    <ol class="algorithm">
      <li>Create an empty list of terms <em>terms</em> that will be populated with
        <tref>term</tref>s that are ranked according to how closely they match
        <em>value</em>. Initialize <em>highest rank</em> to <code>0</code>,
        and set a flag <em>list container</em> to <code>false</code>.</li>
      <li>For each <em>term</em> in the <tref>active context</tref>:
        <ol class="algorithm">
          <li>If the <em>term</em>'s <tref>IRI</tref> is not a complete match against
            <em>iri</em>, continue to the next <em>term</em>.</li>
          <li>If <em>value</em> is a <tref>JSON object</tref> containing only the property <code>@list</code>:
            <ol class="algorithm">
              <li>If <em>term</em> has a <code>@container</code> set to <code>@set</code>, continue
                to the next <em>term</em>.</li>
              <li>If <em>list container</em> is <code>true</code> and <em>term</em> does not have a
                <code>container</code> set to <code>@list</code>, continue to the next <em>term</em>.</li>
            </ol>
          </li>
          <li>Otherwise, if <em>term</em> has a <code>container</code> set to <code>@list</code>,
            continue to the next <em>term</em>.</li>
          <li>Set <em>rank</em> to the <tref>term rank</tref> of <em>value</em> by passing
            passing <em>term</em>, <em>value</em>, and <tref>active context</tref> to
            the <a href="#term-rank-algorithm">Term Rank Algorithm</a>.</li>
          <li>If <em>rank</em> is greater than <code>0</code>:
            <ol class="algorithm">
              <li>If <em>term</em> has a <code>container</code> set to <code>@set</code>, then add
                <code>1</code> to <em>rank</em>.</li>
              <li>If <em>value</em> is a <tref>JSON object</tref> containing only the property <code>@list</code>
                and <em>list container</em> is <code>false</code> and <em>term</em> has a <code>container</code>
                set to <code>@list</code>, then set <em>list container</em> to <code>true</code>, clear
                <em>terms</em>, set <em>highest rank</em> to <em>rank</em>, and add <em>term</em> to <em>terms</em>.</li>
              <li>Otherwise, if <em>rank</em> is greater than or equal to <em>highest rank</em>:
                <ol class="algorithm">
                  <li>If <em>rank</em> is greater than <em>highest rank</em>, clear <em>terms</em> and set
                    <em>highest rank</em> to <em>rank</em>.</li>
                  <li>Add <em>term</em> to <em>terms</em>.</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>If <em>terms</em> is empty, add a <tref>compact IRI</tref> representation of <em>iri</em>
        for each <tref>term</tref> in the <tref>active context</tref> which
        maps to an <tref>IRI</tref> which is a prefix for <em>iri</em> where
        the resulting <tref>compact IRI</tref> is not a <tref>term</tref> in the
        <tref>active context</tref>. The resulting <tref>compact IRI</tref> is the
        <tref>term</tref> associated with the partially
        matched IRI in the <tref>active context</tref> concatenated with a
        colon (:) character and the unmatched part of <em>iri</em>.</li>
      <li>If <em>terms</em> is empty, return <em>iri</em>.</li>
      <li>Otherwise, return the shortest and lexicographically least value in <em>terms</em>.</li>
    </ol>
  </p>
</section>

<section>
<h3>Term Rank Algorithm</h3>
<p>When selecting among multiple possible terms for a given property, it may be that multiple
  <tref title="term">terms</tref> are defined with the same <tref>IRI</tref>, but differ in <code>@type</code>, <code>@container</code>
  or <code>@language</code>. The purpose of this algorithm is to take a <tref>term</tref>
  and a value and give it a <tdef>term rank</tdef>. The selection can then be based, partly, on
  the term having the highest <tref>term rank</tref>.</p>
<p>Given a <tref>term</tref> <em>term</em>, <em>value</em>, and <tref>active context</tref>
  determine the <tref>term rank</tref> using the following steps:</p>
<ol class="algorithm">
  <li>If <em>value</em> is <tref>null</tref>, <tref>term rank</tref> is <code>3</code>.</li>
  <li>Otherwise, if <em>value</em> is a <tref>JSON object</tref> containing only the property <code>@list</code>:
    <ol class="algorithm">
      <li>If the <code>@list</code> property is an empty array, if <em>term</em> has <code>@container</code>
        set to <code>@list</code>, <tref>term rank</tref> is <code>1</code>, otherwise <code>0</code>.</li>
      <li>Otherwise, return the sum of the <tref>term rank</tref>s for every entry in the list.</li>
    </ol>
  </li>
  <li>Otherwise, <em>value</em> MUST be a <tref>subject definition</tref>, <tref>subject reference</tref>,
    or a <tref>JSON object</tref> having a <code>@value</code>.
    <ol class="algorithm">
      <li>If <em>value</em> has a <code>@value</code> property:
        <ol class="algorithm">
          <li>If <em>value</em> has a <code>@type</code> property matching a
            <code>@type</code> coercion for <em>term</em>, <tref>term rank</tref>
            is <code>3</code>, otherwise if <em>term</em> has no <code>@type</code>
            coercion and no <code>@language</code>, <tref>term rank</tref> is
            <code>1</code>, otherwise <code>0</code>.</li>
          <li>Otherwise, if <code>@value</code> is not a <tref>string</tref>, if <em>term</em> has
            no <code>@type</code> or <code>@language</code> it is <code>2</code>, otherwise <code>1</code>.</li>
          <li>Otherwise, if <em>value</em> has no <code>@language</code> property, if <em>term</em> has
            <code>@language</code> <tref>null</tref>, or <em>term</em> has no <code>@type</code> or
            <code>@language</code> and the <tref>active context</tref> has no <code>@language</code>,
            <tref>term rank</tref> is <code>3</code>, otherwise <code>0</code>.</li>
          <li>Otherwise, if <em>value</em> has a <code>@language</code> property matching a
            <code>@language</code> definition for <em>term</em> (or
            <em>term</em> has no <code>@type</code> or <code>@language</code> definition and
            <code>@language</code> in the <tref>active context</tref> matches the
            <em>value</em> <code>@language</code>), <tref>term rank</tref> is
            <code>3</code>, otherwise if <em>term</em> has no <code>@type</code>
            coercion and no <code>@language</code>, <tref>term rank</tref> is
            <code>1</code>, otherwise <code>0</code>.</li>
        </ol>
      </li>
      <li>Otherwise, if <em>term</em> has <code>@type</code> coerced to <code>@id</code>,
        <tref>term rank</tref> is <code>3</code>, otherwise
        if <em>term</em> has no <code>@type</code> coercion and no <code>@language</code>,
        <tref>term rank</tref> is <code>1</code>, otherwise <code>0</code>.</li>
    </ol>
  </li>
  <li>Return <tref>term rank</tref>.</li>
</ol>
</section>

</section>

<section>
  <h2>Value Expansion</h2>
  <p>Some values in JSON-LD can be expressed in a compact form. These values
    are required to be expanded at times when processing JSON-LD documents.</p>

  <p>The algorithm for expanding a <em>value</em> takes an <tref>active property</tref>
    and <tref>active context</tref>. It is implemented as follows:</p>
  <ol class="algorithm">
    <li>If <em>value</em> is <tref>null</tref>, the <em>value</em> is already expanded.</li>
    <li>If <tref>active property</tref> is <code>@graph</code> or the target of an <code>@id</code> coercion,
      expand the value into an object with a key-value pair where the key is <code>@id</code> and the value is
      the expanded IRI according to the <a href="#iri-expansion">IRI Expansion</a> rules.</li>
    <li>Otherwise, if <tref>active property</tref> is not a <tref>keyword</tref>, then expand <em>value</em> into an
      object:
      <ol class="algorithm">
        <li>Set the first key-value pair to <code>@value</code> and the unexpanded <em>value</em>.</li>
        <li>If the <tref>active property</tref> is the target of typed literal coercion, set the second key-value pair
          to <code>@type</code> and the associated coercion datatype expanded according to the
          <a href="#iri-expansion">IRI Expansion</a> rules.</li>
        <li>Otherwise, if the <tref>active property</tref> is the target of language tagging, set the second key-value
          pair to <code>@language</code> and value of the language tagging from the <tref>active context</tref>.</li>
      </ol>
    </li>
    <li>Otherwise, <em>value</em> is already expanded.</li>
  </ol>
</section>

<section>
  <h2>Value Compaction</h2>
  <p>Some values, such as <tref title="IRI">IRIs</tref> and <tref title="typed literal">typed literals</tref>, may be expressed in an
    expanded form in JSON-LD. These values are required to be compacted at
    times when processing JSON-LD documents.
  </p>

  <p>The algorithm for compacting an expanded value <em>value</em> takes an <tref>active property</tref>
    and <tref>active context</tref>. It is implemented as follows:</p>
  <ol class="algorithm">
    <li>If <em>value</em> only has one property, then the compacted value is the value
      of <code>@value</code>.</li>
    <li>Otherwise, if <tref>active property</tref> is <code>@graph</code>, the compacted value is the
      value associated with the <code>@id</code> key, processed according to
      the <a href="#iri-compaction">IRI Compaction</a> steps.</li>
    <li>Otherwise, if the <tref>active context</tref> contains a coercion target for the
      key that matches the expression of the value, compact the value using the
      following steps:
      <ol class="algorithm">
        <li>If the coercion target is an <code>@id</code>, the compacted
          value is the value associated with the <code>@id</code> key,
          processed according to the
          <a href="#iri-compaction">IRI Compaction</a> steps.</li>
        <li>If the coercion target is a <tref>typed literal</tref>, the compacted
          value is the value associated with the <code>@value</code> key.</li>
      </ol>
    </li>
    <li>Otherwise, if <em>value</em> contains an <code>@id</code> key, the compacted value is <em>value</em> with
      the value of <code>@id</code> processed according to the
      <a href="#iri-compaction">IRI Compaction</a> steps.</li>
    <li>Otherwise, if the <tref>active context</tref> contains a <code>@language</code>, which
      matches the <code>@language</code> of the value, or the value has only a <code>@value</code> key, the compacted
      value is the value associated with the <code>@value</code> key.</li>
    <li>Otherwise, if the value contains a <code>@type</code> key, the compacted value
      is <em>value</em> with the <code>@type</code> value processed according to the
      <a href="#iri-compaction">IRI Compaction</a> steps.</li>
    <li>Otherwise, the value is not modified.</li>
  </ol>
</section>

<section>
<h2>Expansion</h2>

<p>Expansion is the process of taking a JSON-LD document and applying a
  context such that all IRI, datatypes, and literal values are expanded so
  that the context is no longer necessary. JSON-LD document expansion
  is typically used as a part of other JSON-LD API methods.</p>

<p>For example, assume the following JSON-LD input document:</p>

<pre class="example" data-transform="updateExample">
<!--
{
   "@context":
   {
      "name": "http://xmlns.com/foaf/0.1/name",
      "homepage": {
        "@id": "http://xmlns.com/foaf/0.1/homepage",
        "@type", "@id"
      }
   },
   "name": "Manu Sporny",
   "homepage": "http://manu.sporny.org/"
}
-->
</pre>

<p>Running the JSON-LD Expansion algorithm against the JSON-LD input document
  provided above would result in the following output:</p>

<pre class="example" data-transform="updateExample">
<!--
{
   "http://xmlns.com/foaf/0.1/name": "Manu Sporny",
   "http://xmlns.com/foaf/0.1/homepage": {
      "@id": "http://manu.sporny.org/"
   }
}
-->
</pre>

<section>
<h3>Expansion Algorithm</h3>

<p>The algorithm takes three input variables: an <tref>active context</tref>,  an <tref>active property</tref>, and an <em>element</em> to be expanded. To
  begin, the <tref>active context</tref> is set to the result of performing, <a
  href="#context-processing">Context Processing</a> on the passed
  <em>context</em>, or to the <tref>initial context</tref> if <em>context</em>
  is <tref>null</tref>, <tref>active property</tref> is set to
  <tref>null</tref>, and <em>element</em> is set to the <tref>JSON-LD
  input</tref>.</p>
<ol class="algorithm">
  <li>If <em>element</em> is an <tref>array</tref>, process each entry in <em>element</em> recursively
    using this algorithm, passing copies of the <tref>active context</tref> and <tref>active property</tref>.
    If has a <code>@container</code> set to <code>@list</code> and any entry in <em>element</em> is an
    <tref>array</tref>, or is a <tref>JSON object</tref> containing a <code>@list</code> property,
    throw an exception, as lists of lists are not allowed.
    If the expanded entry is null, drop it. If it's an array, merge its entries with <em>element</em>'s entries.</li>
  <li>Otherwise, if <em>element</em> is an object
    <ol class="algorithm">
      <li>If <em>element</em> has a <code>@context</code> property, update the <tref>active context</tref> according to
        the steps outlined in <a href="#context-processing">Context Processing</a> and remove the <code>@context</code>
        property.</li>
      <li>Then, proceed and process each <em>property</em> and <em>value</em> in <em>element</em> as follows:
        <ol class="algorithm">
          <li>Remove <em>property</em> from <em>element</em>, expand
            <em>property</em> according to the steps outlined in <a href="#iri-expansion">IRI Expansion</a>.
            Set the <tref>active property</tref> to the original un-expanded <em>property</em> if
            <em>property</em> is not a <tref>keyword</tref>.</li>
          <li>If <em>property</em> does not expand to a keyword or an <tref>absolute IRI</tref> (i.e., it doesn't contain a colon),
            continue with the next property from <em>element</em>.</li>
          <li>If <em>value</em> is <tref>null</tref> and <em>property</em> is not <code>@value</code>, continue with the next
            property from <em>element</em>.</li>
          <li>If the <em>property</em> is <code>@id</code> the <em>value</em> MUST be a <tref>string</tref>.
            Expand the <em>value</em> according to <a href="#iri-expansion">IRI Expansion</a>.</li>
          <li>Otherwise, if the <em>property</em> is <code>@type</code>:
            <ol class="algorithm">
              <li>If <em>value</em> is a <tref>string</tref>, expand according to <a href="#iri-expansion">IRI Expansion</a>.</li>
              <li>Otherwise, if <em>value</em> is a <tref>subject reference</tref>, the expanded value
                is the result of performing <a href="#iri-expansion">IRI Expansion</a> on the value of <code>@id</code>.</li>
              <li>Otherwise, if <em>value</em> is a <tref>JSON Object</tref>, it must be empty (used for
                <cite><a href="../json-ld-framing/#framing">Framing</a></cite>).</li>
              <li>Otherwise, if <em>value</em> is an <tref>array</tref>, all elements must be either a
                <tref>string</tref> or <tref>subject reference</tref>. Expand <em>value</em> for each
                of its entries using the previous three steps.</li>
            </ol>
          </li>
          <li>Otherwise, if the <em>property</em> is <code>@value</code> or <code>@language</code> the <em>value</em> MUST NOT be a
            <tref>JSON object</tref> or an <tref>array</tref>.</li>
          <li>Otherwise, if the <em>property</em> is <code>@list</code> or <code>@set</code> expand <em>value</em>
            recursively using this algorithm, passing copies of the <tref>active context</tref> and <em>active property</em>. If the expanded
            <em>value</em> is not an <tref>array</tref>, convert it to an <tref>array</tref>.
            If <em>property</em> is <code>@list</code> and any entry in <em>value</em> is a
            <tref>JSON object</tref> containing an <code>@list</code> property, throw an exception, as
            lists of lists are not supported.</li>
          <li>Otherwise, expand <em>value</em> recursively using this algorithm, passing copies of the <tref>active context</tref> and
            <tref>active property</tref>.</li>
          <li>If <em>property</em> is not a keyword
            and <tref>active property</tref> has a <code>@container</code> <code>@list</code>
            and the expanded <em>value</em> is not <tref>null</tref>,
            convert <em>value</em> to an <tref>object</tref> with an <code>@list</code> property whose value is
            set to <em>value</em> (unless <em>value</em> is already in that form).</li>
          <li>Convert <em>value</em> to <tref>array</tref> form unless <em>value</em> is <tref>null</tref> or <em>property</em> is
            <code>@id</code>, <code>@type</code>, <code>@value</code>, or <code>@language</code>.</li>
          <li>If <em>value</em> is not <tref>null</tref>, either merge <em>value</em> into an existing <em>property</em> property of
            <em>element</em> or create a new <em>property</em> property with <em>value</em> as value.</li>
        </ol>
      </li>
      <li>If the processed <em>element</em> has an <code>@value</code> property
        <ol class="algorithm">
          <li><em>element</em> MUST NOT have more than one other property, which can either be <code>@language</code> or <code>@type</code>
            with a <tref>string</tref> value.</li>
          <li>if the value of <code>@value</code> equals <tref>null</tref>,
            replace <em>element</em> with the value of <code>@value</code>.</li>
        </ol>
      </li>
      <li>Otherwise, if <em>element</em> has an <code>@type</code> property and its value is not in the form of an
        <tref>array</tref>, convert it to an <tref>array</tref>.</li>
      <li>If <em>element</em> has an <code>@set</code> or <code>@list</code> property, it MUST be the only property.
        Set <em>element</em> to the value of <code>@set</code>; leave <code>@list</code> untouched.</li>
      <li>If <em>element</em> has just a <code>@language</code> property, set <em>element</em> to <tref>null</tref>.</li>
    </ol>
  </li>
  <li>Otherwise, expand <em>element</em> according to the <a href="#value-expansion">Value Expansion</a> rules,
    passing copies of the <tref>active context</tref> and <tref>active property</tref>.</li>
</ol>

<p>If, after the algorithm outlined above is run, the resulting <em>element</em> is an <tref>JSON object</tref> with just a <code>@graph</code>
  property, <em>element</em> is set to the value of <code>@graph</code>'s value. Finally, if <em>element</em> is a <tref>JSON object</tref>,
  it is wrapped into an <tref>array</tref>.</p>

</section>

</section>

<section>
<h2>Compaction</h2>

<p>Compaction is the process of taking a JSON-LD document and applying a
  context such that the most compact form of the document is generated. JSON
  is typically expressed in a very compact, key-value format. That is, full
  IRIs are rarely used as keys. At times, a JSON-LD document may be received
  that is not in its most compact form. JSON-LD, via the API, provides a way
  to compact a JSON-LD document.</p>

<p>For example, assume the following JSON-LD input document:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "http://xmlns.com/foaf/0.1/name": "Manu Sporny",
  "http://xmlns.com/foaf/0.1/homepage": {
    "@id": "http://manu.sporny.org/"
  }
}
-->
</pre>

<p>Additionally, assume the following developer-supplied JSON-LD context:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
  }
}
-->
</pre>

<p>Running the JSON-LD Compaction algorithm given the context supplied above
  against the JSON-LD input document provided above would result in the following
  output:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
  },
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/"
}
-->
</pre>

<p>The compaction algorithm also enables the developer to map any expanded
  format into an application-specific compacted format. While the context
  provided above mapped <code>http://xmlns.com/foaf/0.1/name</code> to
  <strong>name</strong>, it could have also mapped it to any arbitrary string
  provided by the developer.</p>

<section>
<h3>Compaction Algorithm</h3>

<p>The algorithm takes three input variables: an <tref>active context</tref>, an <tref>active property</tref>,
  and an <em>element</em> to be compacted. To begin, the <tref>active context</tref> is
  set to the result of performing <a href="#context-processing">Context Processing</a> on the passed <em>context</em>,
  <tref>active property</tref> is set to <tref>null</tref>, and <em>element</em> is set to the result of performing the
  <a href="#expansion-algorithm">Expansion Algorithm</a> on the <tref>JSON-LD input</tref>. This removes any existing
  context to allow the given <tref>active context</tref> to be cleanly applied.</p>

<ol class="algorithm">
  <li>If <em>element</em> is an <tref>array</tref>, process each entry in <em>element</em> recursively
    using this algorithm, passing a copy of the <tref>active context</tref> and the <tref>active property</tref>.
    If <em>element</em> has a single item, the compacted value is that item; otherwise the compacted value
    is <em>element</em>.</li>
  <li>Otherwise, if <em>element</em> is an object:
    <ol class="algorithm">
      <li>If <em>element</em> has an <code>@value</code> property or element is a <tref>subject reference</tref>,
        return the result of performing
        <a href="#value-compaction">Value Compaction</a> on <em>element</em> using <tref>active property</tref>.</li>
      <li>Otherwise, if the <tref>active property</tref> has a <code>@container</code> mapping to <code>@list</code>
        and <em>element</em> has a corresponding <code>@list</code> property, recursively compact that
        property's value passing a copy of the <tref>active context</tref> and the <tref>active property</tref> ensuring
        that the result is an array and removing <tref>null</tref> values. Return either the
        result as an array, as an object with a key of <code>@list</code> (or appropriate alias from
        <tref>active context</tref>).</li>
      <li>Otherwise, construct <em>output</em> as a new <tref>JSON object</tref> used for returning the result
        of compacting <em>element</em>. For each <em>property</em> and <em>value</em> in <em>element:</em>
        <ol class="algorithm">
          <li>If <em>property</em> is <code>@id</code> or <code>@type</code>
            <ol class="algorithm">
              <li>Set <tref>active property</tref> to the result of performing
                <a href="#iri-compaction">IRI Compaction</a> on <em>property</em>.</li>
              <li>If <em>value</em> is a <tref>string</tref>, the compacted <em>value</em> is the result of performing
                <a href="#iri-compaction">IRI Compaction</a> on <em>value</em>.</li>
              <li>Otherwise, <em>value</em> MUST be an <tref>array</tref>. Perform <a href="#iri-compaction">IRI Compaction</a>
                on every entry of <em>value</em>. If <em>value</em> contains just one entry, <em>value</em> is set to that entry.</li>
              <li>Add <tref>active property</tref> and the expanded <em>value</em> to <em>output</em>.</li>
            </ol>
          </li>
          <li>Otherwise, <em>value</em> MUST be an <tref>array</tref>.</li>
          <li>If <em>value</em> is empty:
            <ol class="algorithm">
              <li>Set <tref>active property</tref> to the result of performing
                <a href="#iri-compaction">IRI Compaction</a> on <em>property</em>.</li>
              <li>Create an entry in <em>output</em> for <tref>active property</tref> and <em>value</em>.</li>
            </ol>
          </li>
          <li>For each <em>item</em> in <em>value</em>:
            <ol class="algorithm">
              <li>Set <tref>active property</tref> to the result of performing <a href="#iri-compaction">IRI Compaction</a>
                for <em>property</em> and <em>item</em> using the <tref>active context</tref>.</li>
              <li>Compact <em>item</em> by recursively performing this algorithm passing a copy of
                the <tref>active context</tref> and the <tref>active property</tref>.</li>
              <li>If an entry already exists in <em>output</em> for <tref>active property</tref>, convert it
                to an <tref>array</tref> if necessary, and append the compacted <em>value</em>.</li>
              <li>Otherwise, if the compacted <em>value</em> is not an <tref>array</tref> and <tref>active property</tref>
                has a <code>@container</code> mapping to <code>@set</code>,
                create an entry in <em>output</em> for <tref>active property</tref> and <em>value</em> as an
                <tref>array</tref>.</li>
              <li>Otherwise, create an entry in <em>output</em> for <tref>active property</tref> and <em>value</em>.</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Otherwise, return <em>element</em> as the compacted <em>element</em>.
    <div class="issue">Perhaps this should also call <a href="#value-compaction">Value Compaction</a> on
      native types and strings, which could consolodate potential transformation in one place.</div>
  </li>
</ol>

<p>If, after the algorithm outlined above is run, the resulting <em>element</em> is an <tref>array</tref>, put <em>element</em> into the
  <code>@graph</code> property of a new <tref>JSON object</tref> and then set <em>element</em> to that <tref>JSON object</tref>.
  Finally, add a <code>@context</code> property to <em>element</em> and set it to the initially passed <em>context</em>.</p>

</section>

</section>

<section>
<h2>RDF Conversion</h2>

<p>A JSON-LD document MAY be converted between other RDF-compatible document
  formats using the algorithms specified in this section.</p>

<p>The JSON-LD Processing Model describes processing rules for extracting RDF
  from a JSON-LD document, and for transforming an array of <a>Quad</a> retrieved by processing
  another serialization format into JSON-LD. Note that many uses of JSON-LD may not require
  generation of RDF.</p>

<p>The processing algorithms described in this section are provided in
  order to demonstrate how one might implement a JSON-LD to RDF processor.
  Conformant implementations are only required to produce the same type and
  number of quads during the output process and are not required to
  implement the algorithm exactly as described.</p>

<section class="informative">
  <h4>Overview</h4>
  <p>
    JSON-LD is intended to have an easy to parse grammar that closely models existing
    practice in using JSON for describing object representations. This allows the use
    of existing libraries for parsing JSON.
  </p>
  <p>
    As with other grammars used for describing <tref>Linked Data</tref>, a key concept is that of
    a <tref>node</tref>. Nodes may be of three basic types: <ldtref>IRI</ldtref>, representing
    <tref title="IRI">IRIs</tref> for describing
    externally named entities, <tref>blank node</tref>, resources for which an external name does not
    exist, or is not known, and <tref>Literal</tref>, which describe terminal entities such as strings,
    dates and other representations having a lexical representation possibly including
    an explicit language or datatype.
  </p>
  <p>Data described with JSON-LD may be considered to be the representation of a graph made
    up of <tref>subject</tref> and <tref>object</tref> <tref title="node">nodes</tref> related via a
    <tref>property</tref> <tref>node</tref>.
    However, specific implementations may choose to operate on the document as a normal
    JSON description of objects having attributes.</p>
</section>

<section>
  <h3>Convert to RDF Algorithm</h3>
  <p>
    The algorithm below is designed for in-memory implementations with random access to <tref>JSON object</tref> elements.
  </p>
  <p>
    A conforming JSON-LD processor implementing RDF conversion MUST implement a
    processing algorithm that results in the same set of RDF <tref title="quad">Quads</tref> that the following
    algorithm generates:
  </p>

  <p>The algorithm takes five input variables: a <em>element</em> to be converted, an
    <tref>active subject</tref>, <tref>active property</tref> and <tref>graph name</tref>.
    To begin, the <tref>active subject</tref>, <tref>active property</tref> and <tref>graph name</tref>
    are set to <tref>null</tref>, and <em>element</em> is
    set to the result of performing the <a href="#expansion-algorithm">Expansion Algorithm</a> on
    the <tref>JSON-LD input</tref>. This removes any existing context to allow the given context to be cleanly
    applied.</p>

  <ol class="algorithm">
    <li id="processing-step-associative">
      If <em>element</em> is a <tref>JSON object</tref>, perform the following steps:
      <ol class="algorithm">
        <li>Set <tref>active object</tref> to <tref>null</tref>.</li>
        <li>
          If <em>element</em> has a <code>@value</code> property:
          <ol class="algorithm">
            <li>If the value of <code>@value</code> is a <tref>number</tref>, set the
              <tref>active object</tref> to a <tref>typed literal</tref> using a string representation
              of the value as defined in the section <a href="#data-round-tripping">Data Round Tripping</a>.
              Set datatype to the value of the <code>@type</code> property if it exists, otherwise
              either <code>xsd:integer</code> or <code>xsd:double</code>, depending
              on if the value contains a fractional and/or an exponential component.</li>
            <li>Otherwise, if the value of <code>@value</code> is <strong>true</strong> or <strong>false</strong>,
              set the <tref>active object</tref> to a <tref>typed literal</tref> created from the
              string representation of the value. Set datatype to the value of the <code>@type</code>
              property if it exists, otherwise <code>xsd:boolean</code>.</li>
            <li>
              Otherwise, if <em>element</em> contains a <code>@type</code> property, set the
              <tref>active object</tref> to a <tref>typed literal</tref>.
            </li>
            <li>
              Otherwise, if <em>element</em> contains a <code>@language</code> property, set the
              <tref>active object</tref> to a <tref>language-tagged literal</tref>.
            </li>
            <li>
              Otherwise, set the <tref>active object</tref> to a <tref>typed literal</tref>
              using <code>xsd:string</code> as the datatype.
            </li>
          </ol>
        </li>
        <li>
          If <em>element</em> has a <code>@list</code> property the value MUST be an <tref>array</tref>.
          Process its value as a list as described in <a href="#list-conversion">List Conversion</a> using
          the return value as the <tref>active object</tref>
        </li>
        <li>If <tref>active object</tref> is not <tref>null</tref>:
          <ol class="algorithm">
            <li>If neither <tref>active subject</tref> nor <tref>active property</tref> are <tref>null</tref>,
              generate a <a>Quad</a>
              representing <tref>active subject</tref>, <tref>active property</tref>,
              <tref>active object</tref>, and <tref>graph name</tref>.</li>
            <li>Return <tref>active object</tref>.</li>
          </ol>
        </li>
        <li id="processing-step-subject">If <em>element</em> has a <code>@id</code> property,
          the value MUST be a <tref>string</tref>, set the <tref>active subject</tref> to the previously
          expanded value (either a <tref>blank node</tref> or an <ldtref>IRI</ldtref>).</li>
        <li>
          Otherwise, if <em>element</em> does not have a <code>@id</code> property, set the <tref>active
          subject</tref> to newly generated <tref>blank node</tref>.</li>
        <li>
          Process each <em>property</em> and <em>value</em> in <em>element</em>, ordered by
          <em>property</em>, as follows:
          <ol class="algorithm">
            <li>
              If <em>property</em> is <code>@type</code>, set the <tref>active property</tref>
              to <code>rdf:type</code>.
            </li>
            <li>Otherwise, if <em>property</em> is <code>@graph</code>,
              process <em>value</em> algorithm recursively, using <tref>active subject</tref> as <tref>graph name</tref>
              and null values for <tref>active subject</tref> and <tref>active property</tref> and then
              proceed to next property.</li>
            <li>Otherwise, if <em>property</em> is a <tref>keyword</tref>, skip this step.</li>
            <li>Otherwise, set <tref>active property</tref> to the IRI value of <em>property</em>.</li>
            <li>Process <em>value</em> recursively using this algorithm, passing copies of
              <tref>active subject</tref>, <tref>active property</tref> and <tref>graph name</tref>.
            </li>
          </ol>
        </li>
        <li>
          Set <tref>active object</tref> to <tref>active subject</tref>.
        </li>
      </ol>
    </li>

    <li>Otherwise, if <em>element</em> is an <tref>array</tref>, process each value in the <tref>array</tref>
      as follows, process <em>element</em> recursively using this algorithm, using copies of
      <tref>active subject</tref>, <tref>active property</tref>, and <tref>graph name</tref>.</li>

    <li>Otherwise, if <em>element</em> is a <tref>string</tref>, then the <tref>active property</tref>
      must be <code>rdf:type</code> so set the <tref>active object</tref> to an <ldtref>IRI</ldtref>.</li>

    <li>If any of these steps created an <tref>active object</tref> and neither <tref>active subject</tref>
      nor <tref>active property</tref> are <tref>null</tref>, generate a <a>Quad</a> using
      <tref>active subject</tref>,<tref>active property</tref>, <tref>active object</tref> and
      <tref>graph name</tref>.
    </li>
    <li>Return <tref>active object</tref>.</li>
  </ol>
</section>
<section id="list-conversion">
  <h3>List Conversion</h3>

  <p>List Conversion is the process of taking an <tref>array</tref> of values and adding them to a newly
    created <cite><a href="http://www.w3.org/TR/rdf-schema/#ch_collectionvocab">RDF Collection</a></cite> (see
    [[!RDF-SCHEMA]]) by linking each element of the list using <code>rdf:first</code> and <code>rdf:next</code>,
    terminating the list with <code>rdf:nil</code> using the following sequence:</p>
  <p>The algorithm is invoked with an <tref>array</tref> <em>array</em>, the <tref>active property</tref>
    and returns a value to be used as an <tref>active object</tref> in the calling location.</p>
  <div class="note">This algorithm does not support lists containing lists.</div>
  <ol class="algorithm">
    <li>
      If <em>array</em> is empty return <code>rdf:nil</code>.
    </li>
    <li>
      Otherwise, generate a <a>Quad</a> using using the <tref>active subject</tref>, <tref>active property</tref>
      and a newly generated <tref>blank node</tref> identified as <em>first <tref>blank node</tref></em>.
    </li>
    <li>
      For each element in <em>array</em> other than the last element:
      <ol class="algorithm">
        <li>Create a processor state using
          <em>first blank node</em> as the <tref>active subject</tref>, and
          <code>rdf:first</code> as the <tref>active property</tref>.
          <ol class="algorithm">
            <li>Process the value starting at <a href="#processing-step-associative">Step 1</a>.</li>
            <li>Proceed using the previous <tref>processor state</tref>.</li>
          </ol>
        </li>
        <li>Unless this is the last element in <em>array</em>, generate a new <tref>blank node</tref> identified as
          <em>rest blank node</em>, otherwise use <code>rdf:nil</code>.</li>
        <li>Generate a new <a>Quad</a> using <em>first blank node</em>,
          <code>rdf:rest</code> and <em>rest blank node</em>.</li>
        <li>Set <em>first blank node</em> to
          <em>rest blank node</em>.</li>
        <li>Return <em>first blank node</em>.</li>
      </ol>
    </li>
  </ol>
</section>

<section>
  <h2>Convert from RDF Algorithm</h2>
  <p>In some cases, data exists natively in Triples or Quads form; for example, if the data was originally
    represented in an RDF graph or triple/quad store. This algorithm is designed to simply translate
    an array of <ldtref title="quad">Quads</ldtref> into a JSON-LD document.</p>
  <p>When expanding <tref>typed literal</tref> values having a datatype of <code>xsd:string</code>,
    the <code>@type</code> MUST NOT be set to <code>xsd:string</code> and the resulting value
    MUST have only a <code>@value</code> property.</p>
  <p>The conversion algorithm takes a single parameter <em>input</em> in the form of an
    array of <a>Quad</a> representations.</p>
  <ol class="algorithm">
    <li id="new_graph">Construct <em>defaultGraph</em> as a <tref>JSON object</tref>
      containing <em>subjects</em> and <em>listMap</em>, each an empty <tref>JSON object</tref>.</li>
    <li>Construct <em>graphs</em> as a <tref>JSON object</tref> containing <em>defaultGraph</em>
      identified by
      an empty <tref>string</tref>.</li>
    <li>For each quad in <em>input</em>:
      <ol class="algorithm">
        <li>Set <em>graph</em> to the entry in <em>graphs</em> identified
          by <em>name</em>, initializing it to a new entry using the mechanism
          described in <a href="#new_graph">Step 1</a>.</li>
        <li>If <em>property</em> is <code>rdf:first</code>,
          use the entry in <em>graph.listMap</em> indexed by <em>subject</em>,
          initializing it to a new <tref>JSON object</tref> if nesessary. Represent
          <em>object</em> in expanded form, as described in
          <a href="#value-expansion">Value Expansion</a>. Add the
          resulting <em>object representation</em> to the entry indexed by
          <em>first</em>, and skip to the next quad.</li>
        <li>If <em>property</em> is <code>rdf:rest</code>:
          <ol class="algorithm">
            <li>If <em>object</em> is a <tref>blank node</tref>, use the entry in
              <em>graph.listMap</em> indexed by <em>subject</em>, initializing it
              to a new <tref>JSON object</tref> if necessary. Add the <em>nominalValue</em> of
              <em>object</em> to the entry indexed by <em>rest</em>.
            </li>
            <li>Skip to the next quad.</li>
          </ol>
        </li>
        <li>If <em>name</em> is not <tref>null</tref>, and <em>defaultGraph.subjects</em>
          does not contain an entry for <em>name</em>,
          create a new entry for <em>name</em> from a new
          <tref>JSON object</tref> with key/value pair of <code>@id</code> and
          a string representation of <em>name</em>.</li>
        <li>Set <em>value</em> as the entry from <em>graph.subjects</em> for
          <em>subject</em>, initializing it to a new
          <tref>JSON object</tref> with key/value pair of <code>@id</code> and
          a string representation of <em>subject</em> if necessary.</li>
        <li>If <em>property</em> is <code>rdf:type</code> and the <em>notType</em>
          option is present and not <tref>true</tref>:
          <ol class="algorithm">
            <li>Append the string representation of <em>object</em> to the array value for the
              key <code>@type</code>, creating an entry in <em>value</em> if necessary.</li>
          </ol>
        </li>
        <li>Otherwise, if <em>object</em> is <code>rdf:nil</code>:
          <ol class="algorithm">
            <li>Let <em>key</em> be the string representation of <em>property</em>.</li>
            <li>Append an empty <code>@list</code> representation to the array value for
              <em>key</em>, creating an entry in <em>value</em> if necessary.</li>
          </ol>
        </li>
        <li>Otherwise,
          <ol class="algorithm">
            <li>Let <em>key</em> be the string representation of <em>property</em> and let
              <em>object representation</em>
              be <em>object</em> represented in expanded form as described in
              <a href="#value-expansion">Value Expansion</a>.</li>
            <li>If <em>object</em> is a <tref>blank node</tref>,
              use the entry in <em>graph.listMap</em> indexed by <em>object</em>,
              initializing it to a new <tref>JSON object</tref> if nesessary.
              Add an entry for <em>head</em> with <em>object representation</em>.</li>
            <li>Append <em>object representation</em> to the array value for
              <em>key</em>, creating an entry in <em>value</em> if necessary.</li>
          </ol>
        </li>
      </ol>
    </li>
    <li>For each <em>name</em> and <em>graph</em> in <em>graphs</em>:
      <ol class="algorithm">
        <li>For each <em>subject</em> and <em>entry</em> in <em>graph</em>
          where <em>entry</em> has both <em>head</em> and <em>first</em> keys:
          <ol class="algorithm">
            <li>Set <em>value</em> to the value of <em>head</em> in <em>entry</em>.</li>
            <li>Remove the entry for <code>@id</code> in <em>value</em>.</li>
            <li>Add an entry to <em>value</em> for <code>@list</code> initialized to a new array
              containing the value of <em>first</em> from <em>entry</em>.</li>
            <li>While <em>entry</em> has a key for <em>rest</em>:
              <ol class="algorithm">
                <li>Set <em>entry</em> to the value of <em>graph.listMap</em> for <em>entry.rest</em>.</li>
                <li>Add the value for <em>entry.first</em> to the list array.</li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li>Create <em>array</em> as an empty <tref>array</tref>.</li>
    <li>For each <em>subject</em> and <em>entry</em> in <em>defaultGraph.subjects</em>
      ordered by <em>subject</em>:
      <ol class="algorithm">
        <li>Add <em>entry</em> to <em>array</em>.</li>
        <li>If <em>graphs</em> has an entry for <em>subject</em>, add a property
          <code>@graph</code> in <em>entry</em> containing the ordered entries
          from <em>graphs[subject].subjects</em>.</li>
      </ol>
    </li>
    <li>Return <em>array</em> as the result.</li>
  </ol>
</section>
</section>

</section>

<section>
<h3>Data Round Tripping</h3>

<p>When coercing numbers to <strong>xsd:integer</strong> or <strong>xsd:double</strong>
  as it, e.g., happens during <a href="#rdf-conversion">RDF Conversion</a>, implementers MUST
  ensure that the result is a canonical lexical representation in the form of a
  <tref>string</tref>. A <tdef>canonical lexical representation</tdef> is a set of literals
  from among the valid set of literals for a datatype such that there is a one-to-one mapping
  between the canonical lexical representation and a value in the value space as defined in
  [[!XMLSCHEMA11-2]]]. In other words, every value MUST be converted to a deterministic string
  representation.</p>
<p>The canonical lexical representation of an <em>integer</em>, i.e., a number without fractions
  or a number coerced to <strong>xsd:integer</strong>, is a finite-length sequence of decimal
  digits (<code>0-9</code>) with an optional leading minus sign; leading zeroes are prohibited.
  To convert the number in JavaScript, implementers can use the following snippet of code:</p>
<pre class="example" data-transform="updateExample">
<!--
(value).toFixed(0).toString()
-->
</pre>
<p>The canonical lexical representation of a <em>double</em>, i.e., a number with fractions
  or a number coerced to <strong>xsd:double</strong>, consists of a mantissa followed by the
  character "E", followed by an exponent. The mantissa MUST be a decimal number. The exponent
  MUST be an integer. Leading zeroes and a preceding plus sign (<code>+</code>) are prohibited
  in the exponent. If the exponent is zero, it must be indicated by <code>E0</code>.
  For the mantissa, the preceding optional plus sign is prohibited and the decimal point is
  required. Leading and trailing zeroes are prohibited subject to the following: number
  representations must be normalized such that there is a single digit which is non-zero to the
  left of the decimal point and at least a single digit to the right of the decimal point unless
  the value being represented is zero. The canonical representation for zero is <code>0.0E0</code>.
  To convert the number in JavaScript, implementers can use the following snippet of code:</p>
<pre class="example" data-transform="updateExample">
<!--
(value).toExponential().replace(/e\+?/,'E')
-->
</pre>
<p><strong>xsd:double</strong>'s value space is defined by the IEEE double-precision 64-bit
floating point type [[!IEEE-754-1985]].</p>

<p class="note">When data such as decimals need to be normalized, JSON-LD authors should
not use values that are going to undergo automatic conversion. This is due to the lossy nature
of <strong>xsd:double</strong> values. Authors should instead use the expanded object form to
set the canonical lexical representation directly.</p>

<p class="note">When JSON-native datatypes, like <tref>number</tref>s, are type coerced, lossless
data round-tripping can not be guaranted. Consider the following code example:</p>

<pre class="example" data-transform="updateExample">
<!--
var myObj1 = {
               "@context": {
                 "number": {
                   "@id": "http://example.com/vocab#number",
                   ****"@type": "xsd:nonNegativeInteger"****
                 }
               },
               "number" : ****42****
             };

// Convert the JSON-LD document to RDF; this converts 42 to a string
var jsonldText = jsonld.toRDF(myObj1, myRdfTripleCollector);

// Convert the RDF triples back to a JavaScript object
var myObj2 = jsonld.fromRDF(myRdfTripleCollector.getTriples());
-->
</pre>

<p>At this point, <code>myObj1</code> and <code>myObj2</code> will have different
  values for the "number" property. <code>myObj1</code> will have the number
  <code>42</code>, while <code>myObj2</code> have an object consisting of
  <code>@value</code> set to the string <code>"42"</code> and <code>@type</code>
  set to the expanded value of <em>xsd:nonNegativeInteger</em>.</p>

<p class="note">Some JSON serializers, such as PHP's native implementation in some versions,
  backslash-escape the forward slash character. For example, the value
  <code>http://example.com/</code> would be serialized as <code>http:\/\/example.com\/</code>.
  This is problematic as other JSON parsers might not understand those escaping characters.
  There is no need to backslash-escape forward slashes in JSON-LD. To aid interoperability
  between JSON-LD processors, a JSON-LD serializer MUST NOT backslash-escape forward slashes.</p>

</section>

<section class="appendix" id="appendix-a">
  <h1>Initial Context</h1>
  <p>The <tref>initial context</tref> is defined with the following default entries:</p>
<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type": { "@type": "@id"}
  }
}
-->
</pre>
  <p>Processors MUST act as if the initial context is defined in the outer-most level when processing
    JSON-LD documents.</p>
  <p class="issue">Should we define other default prefixes?</p>
</section>

<section class="appendix">
<h1>Acknowledgements</h1>

<p>The editors would like to thank Mark Birbeck, who provided a great deal of
the initial push behind the JSON-LD work via his work on RDFj,
Dave Lehn and Mike Johnson who reviewed, provided feedback, and
performed several implementations of the specification, and Ian Davis, who
created RDF/JSON. Thanks also to Nathan Rixham, Bradley P. Allen,
Kingsley Idehen, Glenn McDonald, Alexandre Passant, Danny Ayers, Ted
Thibodeau Jr., Olivier Grisel, Niklas Lindström, and Richard
Cyganiak for their input on the specification.
</p>
</section>

</body>
</html>
